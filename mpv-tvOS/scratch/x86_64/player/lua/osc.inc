// Generated from player/lua/osc.lua

"local assdraw = require 'mp.assdraw'\n"
"local msg = require 'mp.msg'\n"
"local opt = require 'mp.options'\n"
"local utils = require 'mp.utils'\n"
"\n"
"--\n"
"-- Parameters\n"
"--\n"
"-- default user option values\n"
"-- do not touch, change them in osc.conf\n"
"local user_opts = {\n"
"    showwindowed = true,        -- show OSC when windowed?\n"
"    showfullscreen = true,      -- show OSC when fullscreen?\n"
"    scalewindowed = 1,          -- scaling of the controller when windowed\n"
"    scalefullscreen = 1,        -- scaling of the controller when fullscreen\n"
"    scaleforcedwindow = 2,      -- scaling when rendered on a forced window\n"
"    vidscale = true,            -- scale the controller with the video?\n"
"    valign = 0.8,               -- vertical alignment, -1 (top) to 1 (bottom)\n"
"    halign = 0,                 -- horizontal alignment, -1 (left) to 1 (right)\n"
"    barmargin = 0,              -- vertical margin of top/bottombar\n"
"    boxalpha = 80,              -- alpha of the background box,\n"
"                                -- 0 (opaque) to 255 (fully transparent)\n"
"    hidetimeout = 500,          -- duration in ms until the OSC hides if no\n"
"                                -- mouse movement. enforced non-negative for the\n"
"                                -- user, but internally negative is \"always-on\".\n"
"    fadeduration = 200,         -- duration of fade out in ms, 0 = no fade\n"
"    deadzonesize = 0.5,         -- size of deadzone\n"
"    minmousemove = 0,           -- minimum amount of pixels the mouse has to\n"
"                                -- move between ticks to make the OSC show up\n"
"    iamaprogrammer = false,     -- use native mpv values and disable OSC\n"
"                                -- internal track list management (and some\n"
"                                -- functions that depend on it)\n"
"    layout = \"bottombar\",\n"
"    seekbarstyle = \"bar\",       -- bar, diamond or knob\n"
"    seekbarhandlesize = 0.6,    -- size ratio of the diamond and knob handle\n"
"    seekrangestyle = \"inverted\",-- bar, line, slider, inverted or none\n"
"    seekrangeseparate = true,   -- wether the seekranges overlay on the bar-style seekbar\n"
"    seekrangealpha = 200,       -- transparency of seekranges\n"
"    seekbarkeyframes = true,    -- use keyframes when dragging the seekbar\n"
"    title = \"\044{media-title}\",   -- string compatible with property-expansion\n"
"                                -- to be shown as OSC title\n"
"    tooltipborder = 1,          -- border of tooltip in bottom/topbar\n"
"    timetotal = false,          -- display total time instead of remaining time?\n"
"    timems = false,             -- display timecodes with milliseconds?\n"
"    visibility = \"auto\",        -- only used at init to set visibility_mode(...)\n"
"    boxmaxchars = 80,           -- title crop threshold for box layout\n"
"    boxvideo = false,           -- apply osc_param.video_margins to video\n"
"    windowcontrols = \"auto\",    -- whether to show window controls\n"
"    windowcontrols_alignment = \"right\", -- which side to show window controls on\n"
"    greenandgrumpy = false,     -- disable santa hat\n"
"}\n"
"\n"
"-- read options from config and command-line\n"
"opt.read_options(user_opts, \"osc\", function(list) update_options(list) end)\n"
"\n"
"local osc_param = { -- calculated by osc_init()\n"
"    playresy = 0,                           -- canvas size Y\n"
"    playresx = 0,                           -- canvas size X\n"
"    display_aspect = 1,\n"
"    unscaled_y = 0,\n"
"    areas = {},\n"
"    video_margins = {\n"
"        l = 0, r = 0, t = 0, b = 0,         -- left/right/top/bottom\n"
"    },\n"
"}\n"
"\n"
"local osc_styles = {\n"
"    bigButtons = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs50\\\\fnmpv-osd-symbols}\",\n"
"    smallButtonsL = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs19\\\\fnmpv-osd-symbols}\",\n"
"    smallButtonsLlabel = \"{\\\\fscx105\\\\fscy105\\\\fn\" .. mp.get_property(\"options/osd-font\") .. \"}\",\n"
"    smallButtonsR = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs30\\\\fnmpv-osd-symbols}\",\n"
"    topButtons = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs12\\\\fnmpv-osd-symbols}\",\n"
"\n"
"    elementDown = \"{\\\\1c&H999999}\",\n"
"    timecodes = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs20}\",\n"
"    vidtitle = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs12\\\\q2}\",\n"
"    box = \"{\\\\rDefault\\\\blur0\\\\bord1\\\\1c&H000000\\\\3c&HFFFFFF}\",\n"
"\n"
"    topButtonsBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs18\\\\fnmpv-osd-symbols}\",\n"
"    smallButtonsBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs28\\\\fnmpv-osd-symbols}\",\n"
"    timecodesBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs27}\",\n"
"    timePosBar = \"{\\\\blur0\\\\bord\".. user_opts.tooltipborder ..\"\\\\1c&HFFFFFF\\\\3c&H000000\\\\fs30}\",\n"
"    vidtitleBar = \"{\\\\blur0\\\\bord0\\\\1c&HFFFFFF\\\\3c&HFFFFFF\\\\fs18\\\\q2}\",\n"
"\n"
"    wcButtons = \"{\\\\1c&HFFFFFF\\\\fs24\\\\fnmpv-osd-symbols}\",\n"
"    wcTitle = \"{\\\\1c&HFFFFFF\\\\fs24\\\\q2}\",\n"
"    wcBar = \"{\\\\1c&H000000}\",\n"
"}\n"
"\n"
"-- internal states, do not touch\n"
"local state = {\n"
"    showtime,                               -- time of last invocation (last mouse move)\n"
"    osc_visible = false,\n"
"    anistart,                               -- time when the animation started\n"
"    anitype,                                -- current type of animation\n"
"    animation,                              -- current animation alpha\n"
"    mouse_down_counter = 0,                 -- used for softrepeat\n"
"    active_element = nil,                   -- nil = none, 0 = background, 1+ = see elements[]\n"
"    active_event_source = nil,              -- the \"button\" that issued the current event\n"
"    rightTC_trem = not user_opts.timetotal, -- if the right timecode should display total or remaining time\n"
"    tc_ms = user_opts.timems,               -- Should the timecodes display their time with milliseconds\n"
"    mp_screen_sizeX, mp_screen_sizeY,       -- last screen-resolution, to detect resolution changes to issue reINITs\n"
"    initREQ = false,                        -- is a re-init request pending?\n"
"    last_mouseX, last_mouseY,               -- last mouse position, to detect significant mouse movement\n"
"    message_text,\n"
"    message_timeout,\n"
"    fullscreen = false,\n"
"    tick_timer = nil,\n"
"    tick_last_time = 0,                     -- when the last tick() was run\n"
"    hide_timer = nil,\n"
"    cache_state = nil,\n"
"    idle = false,\n"
"    enabled = true,\n"
"    input_enabled = true,\n"
"    showhide_enabled = false,\n"
"    dmx_cache = 0,\n"
"    using_video_margins = false,\n"
"    border = true,\n"
"    maximized = false,\n"
"    osd = mp.create_osd_overlay(\"ass-events\"),\n"
"}\n"
"\n"
"local window_control_box_width = 80\n"
"local tick_delay = 0.03\n"
"\n"
"local is_december = os.date(\"*t\").month == 12\n"
"\n"
"--\n"
"-- Helperfunctions\n"
"--\n"
"\n"
"function set_osd(res_x, res_y, text)\n"
"    if state.osd.res_x == res_x and\n"
"       state.osd.res_y == res_y and\n"
"       state.osd.data == text then\n"
"        return\n"
"    end\n"
"    state.osd.res_x = res_x\n"
"    state.osd.res_y = res_y\n"
"    state.osd.data = text\n"
"    state.osd.z = 1000\n"
"    state.osd:update()\n"
"end\n"
"\n"
"local margins_opts = {\n"
"    {\"l\", \"video-margin-ratio-left\"},\n"
"    {\"r\", \"video-margin-ratio-right\"},\n"
"    {\"t\", \"video-margin-ratio-top\"},\n"
"    {\"b\", \"video-margin-ratio-bottom\"},\n"
"}\n"
"\n"
"-- scale factor for translating between real and virtual ASS coordinates\n"
"function get_virt_scale_factor()\n"
"    local w, h = mp.get_osd_size()\n"
"    if w <= 0 or h <= 0 then\n"
"        return 0, 0\n"
"    end\n"
"    return osc_param.playresx / w, osc_param.playresy / h\n"
"end\n"
"\n"
"-- return mouse position in virtual ASS coordinates (playresx/y)\n"
"function get_virt_mouse_pos()\n"
"    local sx, sy = get_virt_scale_factor()\n"
"    local x, y = mp.get_mouse_pos()\n"
"    return x * sx, y * sy\n"
"end\n"
"\n"
"function set_virt_mouse_area(x0, y0, x1, y1, name)\n"
"    local sx, sy = get_virt_scale_factor()\n"
"    mp.set_mouse_area(x0 / sx, y0 / sy, x1 / sx, y1 / sy, name)\n"
"end\n"
"\n"
"function scale_value(x0, x1, y0, y1, val)\n"
"    local m = (y1 - y0) / (x1 - x0)\n"
"    local b = y0 - (m * x0)\n"
"    return (m * val) + b\n"
"end\n"
"\n"
"-- returns hitbox spanning coordinates (top left, bottom right corner)\n"
"-- according to alignment\n"
"function get_hitbox_coords(x, y, an, w, h)\n"
"\n"
"    local alignments = {\n"
"      [1] = function () return x, y-h, x+w, y end,\n"
"      [2] = function () return x-(w/2), y-h, x+(w/2), y end,\n"
"      [3] = function () return x-w, y-h, x, y end,\n"
"\n"
"      [4] = function () return x, y-(h/2), x+w, y+(h/2) end,\n"
"      [5] = function () return x-(w/2), y-(h/2), x+(w/2), y+(h/2) end,\n"
"      [6] = function () return x-w, y-(h/2), x, y+(h/2) end,\n"
"\n"
"      [7] = function () return x, y, x+w, y+h end,\n"
"      [8] = function () return x-(w/2), y, x+(w/2), y+h end,\n"
"      [9] = function () return x-w, y, x, y+h end,\n"
"    }\n"
"\n"
"    return alignments[an]()\n"
"end\n"
"\n"
"function get_hitbox_coords_geo(geometry)\n"
"    return get_hitbox_coords(geometry.x, geometry.y, geometry.an,\n"
"        geometry.w, geometry.h)\n"
"end\n"
"\n"
"function get_element_hitbox(element)\n"
"    return element.hitbox.x1, element.hitbox.y1,\n"
"        element.hitbox.x2, element.hitbox.y2\n"
"end\n"
"\n"
"function mouse_hit(element)\n"
"    return mouse_hit_coords(get_element_hitbox(element))\n"
"end\n"
"\n"
"function mouse_hit_coords(bX1, bY1, bX2, bY2)\n"
"    local mX, mY = get_virt_mouse_pos()\n"
"    return (mX >= bX1 and mX <= bX2 and mY >= bY1 and mY <= bY2)\n"
"end\n"
"\n"
"function limit_range(min, max, val)\n"
"    if val > max then\n"
"        val = max\n"
"    elseif val < min then\n"
"        val = min\n"
"    end\n"
"    return val\n"
"end\n"
"\n"
"-- translate value into element coordinates\n"
"function get_slider_ele_pos_for(element, val)\n"
"\n"
"    local ele_pos = scale_value(\n"
"        element.slider.min.value, element.slider.max.value,\n"
"        element.slider.min.ele_pos, element.slider.max.ele_pos,\n"
"        val)\n"
"\n"
"    return limit_range(\n"
"        element.slider.min.ele_pos, element.slider.max.ele_pos,\n"
"        ele_pos)\n"
"end\n"
"\n"
"-- translates global (mouse) coordinates to value\n"
"function get_slider_value_at(element, glob_pos)\n"
"\n"
"    local val = scale_value(\n"
"        element.slider.min.glob_pos, element.slider.max.glob_pos,\n"
"        element.slider.min.value, element.slider.max.value,\n"
"        glob_pos)\n"
"\n"
"    return limit_range(\n"
"        element.slider.min.value, element.slider.max.value,\n"
"        val)\n"
"end\n"
"\n"
"-- get value at current mouse position\n"
"function get_slider_value(element)\n"
"    return get_slider_value_at(element, get_virt_mouse_pos())\n"
"end\n"
"\n"
"function countone(val)\n"
"    if not (user_opts.iamaprogrammer) then\n"
"        val = val + 1\n"
"    end\n"
"    return val\n"
"end\n"
"\n"
"-- align:  -1 .. +1\n"
"-- frame:  size of the containing area\n"
"-- obj:    size of the object that should be positioned inside the area\n"
"-- margin: min. distance from object to frame (as long as -1 <= align <= +1)\n"
"function get_align(align, frame, obj, margin)\n"
"    return (frame / 2) + (((frame / 2) - margin - (obj / 2)) * align)\n"
"end\n"
"\n"
"-- multiplies two alpha values, formular can probably be improved\n"
"function mult_alpha(alphaA, alphaB)\n"
"    return 255 - (((1-(alphaA/255)) * (1-(alphaB/255))) * 255)\n"
"end\n"
"\n"
"function add_area(name, x1, y1, x2, y2)\n"
"    -- create area if needed\n"
"    if (osc_param.areas[name] == nil) then\n"
"        osc_param.areas[name] = {}\n"
"    end\n"
"    table.insert(osc_param.areas[name], {x1=x1, y1=y1, x2=x2, y2=y2})\n"
"end\n"
"\n"
"function ass_append_alpha(ass, alpha, modifier)\n"
"    local ar = {}\n"
"\n"
"    for ai, av in pairs(alpha) do\n"
"        av = mult_alpha(av, modifier)\n"
"        if state.animation then\n"
"            av = mult_alpha(av, state.animation)\n"
"        end\n"
"        ar[ai] = av\n"
"    end\n"
"\n"
"    ass:append(string.format(\"{\\\\1a&H%X&\\\\2a&H%X&\\\\3a&H%X&\\\\4a&H%X&}\",\n"
"               ar[1], ar[2], ar[3], ar[4]))\n"
"end\n"
"\n"
"function ass_draw_rr_h_cw(ass, x0, y0, x1, y1, r1, hexagon, r2)\n"
"    if hexagon then\n"
"        ass:hexagon_cw(x0, y0, x1, y1, r1, r2)\n"
"    else\n"
"        ass:round_rect_cw(x0, y0, x1, y1, r1, r2)\n"
"    end\n"
"end\n"
"\n"
"function ass_draw_rr_h_ccw(ass, x0, y0, x1, y1, r1, hexagon, r2)\n"
"    if hexagon then\n"
"        ass:hexagon_ccw(x0, y0, x1, y1, r1, r2)\n"
"    else\n"
"        ass:round_rect_ccw(x0, y0, x1, y1, r1, r2)\n"
"    end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- Tracklist Management\n"
"--\n"
"\n"
"local nicetypes = {video = \"Video\", audio = \"Audio\", sub = \"Subtitle\"}\n"
"\n"
"-- updates the OSC internal playlists, should be run each time the track-layout changes\n"
"function update_tracklist()\n"
"    local tracktable = mp.get_property_native(\"track-list\", {})\n"
"\n"
"    -- by osc_id\n"
"    tracks_osc = {}\n"
"    tracks_osc.video, tracks_osc.audio, tracks_osc.sub = {}, {}, {}\n"
"    -- by mpv_id\n"
"    tracks_mpv = {}\n"
"    tracks_mpv.video, tracks_mpv.audio, tracks_mpv.sub = {}, {}, {}\n"
"    for n = 1, #tracktable do\n"
"        if not (tracktable[n].type == \"unknown\") then\n"
"            local type = tracktable[n].type\n"
"            local mpv_id = tonumber(tracktable[n].id)\n"
"\n"
"            -- by osc_id\n"
"            table.insert(tracks_osc[type], tracktable[n])\n"
"\n"
"            -- by mpv_id\n"
"            tracks_mpv[type][mpv_id] = tracktable[n]\n"
"            tracks_mpv[type][mpv_id].osc_id = #tracks_osc[type]\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- return a nice list of tracks of the given type (video, audio, sub)\n"
"function get_tracklist(type)\n"
"    local msg = \"Available \" .. nicetypes[type] .. \" Tracks: \"\n"
"    if #tracks_osc[type] == 0 then\n"
"        msg = msg .. \"none\"\n"
"    else\n"
"        for n = 1, #tracks_osc[type] do\n"
"            local track = tracks_osc[type][n]\n"
"            local lang, title, selected = \"unknown\", \"\", \"\342\227\213\"\n"
"            if not(track.lang == nil) then lang = track.lang end\n"
"            if not(track.title == nil) then title = track.title end\n"
"            if (track.id == tonumber(mp.get_property(type))) then\n"
"                selected = \"\342\227\217\"\n"
"            end\n"
"            msg = msg..\"\\n\"..selected..\" \"..n..\": [\"..lang..\"] \"..title\n"
"        end\n"
"    end\n"
"    return msg\n"
"end\n"
"\n"
"-- relatively change the track of given <type> by <next> tracks\n"
"    --(+1 -> next, -1 -> previous)\n"
"function set_track(type, next)\n"
"    local current_track_mpv, current_track_osc\n"
"    if (mp.get_property(type) == \"no\") then\n"
"        current_track_osc = 0\n"
"    else\n"
"        current_track_mpv = tonumber(mp.get_property(type))\n"
"        current_track_osc = tracks_mpv[type][current_track_mpv].osc_id\n"
"    end\n"
"    local new_track_osc = (current_track_osc + next) % (#tracks_osc[type] + 1)\n"
"    local new_track_mpv\n"
"    if new_track_osc == 0 then\n"
"        new_track_mpv = \"no\"\n"
"    else\n"
"        new_track_mpv = tracks_osc[type][new_track_osc].id\n"
"    end\n"
"\n"
"    mp.commandv(\"set\", type, new_track_mpv)\n"
"\n"
"        if (new_track_osc == 0) then\n"
"        show_message(nicetypes[type] .. \" Track: none\")\n"
"    else\n"
"        show_message(nicetypes[type]  .. \" Track: \"\n"
"            .. new_track_osc .. \"/\" .. #tracks_osc[type]\n"
"            .. \" [\".. (tracks_osc[type][new_track_osc].lang or \"unknown\") ..\"] \"\n"
"            .. (tracks_osc[type][new_track_osc].title or \"\"))\n"
"    end\n"
"end\n"
"\n"
"-- get the currently selected track of <type>, OSC-style counted\n"
"function get_track(type)\n"
"    local track = mp.get_property(type)\n"
"    if track ~= \"no\" and track ~= nil then\n"
"        local tr = tracks_mpv[type][tonumber(track)]\n"
"        if tr then\n"
"            return tr.osc_id\n"
"        end\n"
"    end\n"
"    return 0\n"
"end\n"
"\n"
"-- WindowControl helpers\n"
"function window_controls_enabled()\n"
"    val = user_opts.windowcontrols\n"
"    if val == \"auto\" then\n"
"        return not state.border\n"
"    else\n"
"        return val ~= \"no\"\n"
"    end\n"
"end\n"
"\n"
"function window_controls_alignment()\n"
"    return user_opts.windowcontrols_alignment\n"
"end\n"
"\n"
"--\n"
"-- Element Management\n"
"--\n"
"\n"
"local elements = {}\n"
"\n"
"function prepare_elements()\n"
"\n"
"    -- remove elements without layout or invisble\n"
"    local elements2 = {}\n"
"    for n, element in pairs(elements) do\n"
"        if not (element.layout == nil) and (element.visible) then\n"
"            table.insert(elements2, element)\n"
"        end\n"
"    end\n"
"    elements = elements2\n"
"\n"
"    function elem_compare (a, b)\n"
"        return a.layout.layer < b.layout.layer\n"
"    end\n"
"\n"
"    table.sort(elements, elem_compare)\n"
"\n"
"\n"
"    for _,element in pairs(elements) do\n"
"\n"
"        local elem_geo = element.layout.geometry\n"
"\n"
"        -- Calculate the hitbox\n"
"        local bX1, bY1, bX2, bY2 = get_hitbox_coords_geo(elem_geo)\n"
"        element.hitbox = {x1 = bX1, y1 = bY1, x2 = bX2, y2 = bY2}\n"
"\n"
"        local style_ass = assdraw.ass_new()\n"
"\n"
"        -- prepare static elements\n"
"        style_ass:append(\"{}\") -- hack to troll new_event into inserting a \\n\n"
"        style_ass:new_event()\n"
"        style_ass:pos(elem_geo.x, elem_geo.y)\n"
"        style_ass:an(elem_geo.an)\n"
"        style_ass:append(element.layout.style)\n"
"\n"
"        element.style_ass = style_ass\n"
"\n"
"        local static_ass = assdraw.ass_new()\n"
"\n"
"\n"
"        if (element.type == \"box\") then\n"
"            --draw box\n"
"            static_ass:draw_start()\n"
"            ass_draw_rr_h_cw(static_ass, 0, 0, elem_geo.w, elem_geo.h,\n"
"                             element.layout.box.radius, element.layout.box.hexagon)\n"
"            static_ass:draw_stop()\n"
"\n"
"        elseif (element.type == \"slider\") then\n"
"            --draw static slider parts\n"
"\n"
"            local r1 = 0\n"
"            local r2 = 0\n"
"            local slider_lo = element.layout.slider\n"
"            -- offset between element outline and drag-area\n"
"            local foV = slider_lo.border + slider_lo.gap\n"
"\n"
"            -- calculate positions of min and max points\n"
"            if (slider_lo.stype ~= \"bar\") then\n"
"                r1 = elem_geo.h / 2\n"
"                element.slider.min.ele_pos = elem_geo.h / 2\n"
"                element.slider.max.ele_pos = elem_geo.w - (elem_geo.h / 2)\n"
"                if (slider_lo.stype == \"diamond\") then\n"
"                    r2 = (elem_geo.h - 2 * slider_lo.border) / 2\n"
"                elseif (slider_lo.stype == \"knob\") then\n"
"                    r2 = r1\n"
"                end\n"
"            else\n"
"                element.slider.min.ele_pos =\n"
"                    slider_lo.border + slider_lo.gap\n"
"                element.slider.max.ele_pos =\n"
"                    elem_geo.w - (slider_lo.border + slider_lo.gap)\n"
"            end\n"
"\n"
"            element.slider.min.glob_pos =\n"
"                element.hitbox.x1 + element.slider.min.ele_pos\n"
"            element.slider.max.glob_pos =\n"
"                element.hitbox.x1 + element.slider.max.ele_pos\n"
"\n"
"            -- -- --\n"
"\n"
"            static_ass:draw_start()\n"
"\n"
"            -- the box\n"
"            ass_draw_rr_h_cw(static_ass, 0, 0, elem_geo.w, elem_geo.h, r1, slider_lo.stype == \"diamond\")\n"
"\n"
"            -- the \"hole\"\n"
"            ass_draw_rr_h_ccw(static_ass, slider_lo.border, slider_lo.border,\n"
"                              elem_geo.w - slider_lo.border, elem_geo.h - slider_lo.border,\n"
"                              r2, slider_lo.stype == \"diamond\")\n"
"\n"
"            -- marker nibbles\n"
"            if not (element.slider.markerF == nil) and (slider_lo.gap > 0) then\n"
"                local markers = element.slider.markerF()\n"
"                for _,marker in pairs(markers) do\n"
"                    if (marker > element.slider.min.value) and\n"
"                        (marker < element.slider.max.value) then\n"
"\n"
"                        local s = get_slider_ele_pos_for(element, marker)\n"
"\n"
"                        if (slider_lo.gap > 1) then -- draw triangles\n"
"\n"
"                            local a = slider_lo.gap / 0.5 --0.866\n"
"\n"
"                            --top\n"
"                            if (slider_lo.nibbles_top) then\n"
"                                static_ass:move_to(s - (a/2), slider_lo.border)\n"
"                                static_ass:line_to(s + (a/2), slider_lo.border)\n"
"                                static_ass:line_to(s, foV)\n"
"                            end\n"
"\n"
"                            --bottom\n"
"                            if (slider_lo.nibbles_bottom) then\n"
"                                static_ass:move_to(s - (a/2),\n"
"                                    elem_geo.h - slider_lo.border)\n"
"                                static_ass:line_to(s,\n"
"                                    elem_geo.h - foV)\n"
"                                static_ass:line_to(s + (a/2),\n"
"                                    elem_geo.h - slider_lo.border)\n"
"                            end\n"
"\n"
"                        else -- draw 2x1px nibbles\n"
"\n"
"                            --top\n"
"                            if (slider_lo.nibbles_top) then\n"
"                                static_ass:rect_cw(s - 1, slider_lo.border,\n"
"                                    s + 1, slider_lo.border + slider_lo.gap);\n"
"                            end\n"
"\n"
"                            --bottom\n"
"                            if (slider_lo.nibbles_bottom) then\n"
"                                static_ass:rect_cw(s - 1,\n"
"                                    elem_geo.h -slider_lo.border -slider_lo.gap,\n"
"                                    s + 1, elem_geo.h - slider_lo.border);\n"
"                            end\n"
"                        end\n"
"                    end\n"
"                end\n"
"            end\n"
"        end\n"
"\n"
"        element.static_ass = static_ass\n"
"\n"
"\n"
"        -- if the element is supposed to be disabled,\n"
"        -- style it accordingly and kill the eventresponders\n"
"        if not (element.enabled) then\n"
"            element.layout.alpha[1] = 136\n"
"            element.eventresponder = nil\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"\n"
"--\n"
"-- Element Rendering\n"
"--\n"
"\n"
"function render_elements(master_ass)\n"
"\n"
"    for n=1, #elements do\n"
"        local element = elements[n]\n"
"\n"
"        local style_ass = assdraw.ass_new()\n"
"        style_ass:merge(element.style_ass)\n"
"        ass_append_alpha(style_ass, element.layout.alpha, 0)\n"
"\n"
"        if element.eventresponder and (state.active_element == n) then\n"
"\n"
"            -- run render event functions\n"
"            if not (element.eventresponder.render == nil) then\n"
"                element.eventresponder.render(element)\n"
"            end\n"
"\n"
"            if mouse_hit(element) then\n"
"                -- mouse down styling\n"
"                if (element.styledown) then\n"
"                    style_ass:append(osc_styles.elementDown)\n"
"                end\n"
"\n"
"                if (element.softrepeat) and (state.mouse_down_counter >= 15\n"
"                    and state.mouse_down_counter % 5 == 0) then\n"
"\n"
"                    element.eventresponder[state.active_event_source..\"_down\"](element)\n"
"                end\n"
"                state.mouse_down_counter = state.mouse_down_counter + 1\n"
"            end\n"
"\n"
"        end\n"
"\n"
"        local elem_ass = assdraw.ass_new()\n"
"\n"
"        elem_ass:merge(style_ass)\n"
"\n"
"        if not (element.type == \"button\") then\n"
"            elem_ass:merge(element.static_ass)\n"
"        end\n"
"\n"
"        if (element.type == \"slider\") then\n"
"\n"
"            local slider_lo = element.layout.slider\n"
"            local elem_geo = element.layout.geometry\n"
"            local s_min = element.slider.min.value\n"
"            local s_max = element.slider.max.value\n"
"\n"
"            -- draw pos marker\n"
"            local foH, xp\n"
"            local pos = element.slider.posF()\n"
"            local foV = slider_lo.border + slider_lo.gap\n"
"            local innerH = elem_geo.h - (2 * foV)\n"
"            local seekRanges = element.slider.seekRangesF()\n"
"            local seekRangeLineHeight = innerH / 5\n"
"\n"
"            if slider_lo.stype ~= \"bar\" then\n"
"                foH = elem_geo.h / 2\n"
"            else\n"
"                foH = slider_lo.border + slider_lo.gap\n"
"            end\n"
"\n"
"            if pos then\n"
"                xp = get_slider_ele_pos_for(element, pos)\n"
"\n"
"                if slider_lo.stype ~= \"bar\" then\n"
"                    local r = (user_opts.seekbarhandlesize * innerH) / 2\n"
"                    ass_draw_rr_h_cw(elem_ass, xp - r, foH - r,\n"
"                                     xp + r, foH + r,\n"
"                                     r, slider_lo.stype == \"diamond\")\n"
"                else\n"
"                    local h = 0\n"
"                    if seekRanges and user_opts.seekrangeseparate and slider_lo.rtype ~= \"inverted\" then\n"
"                        h = seekRangeLineHeight\n"
"                    end\n"
"                    elem_ass:rect_cw(foH, foV, xp, elem_geo.h - foV - h)\n"
"\n"
"                    if seekRanges and not user_opts.seekrangeseparate and slider_lo.rtype ~= \"inverted\" then\n"
"                        -- Punch holes for the seekRanges to be drawn later\n"
"                        for _,range in pairs(seekRanges) do\n"
"                            if range[\"start\"] < pos then\n"
"                                local pstart = get_slider_ele_pos_for(element, range[\"start\"])\n"
"                                local pend = xp\n"
"\n"
"                                if pos > range[\"end\"] then\n"
"                                    pend = get_slider_ele_pos_for(element, range[\"end\"])\n"
"                                end\n"
"                                elem_ass:rect_ccw(pstart, elem_geo.h - foV - seekRangeLineHeight, pend, elem_geo.h - foV)\n"
"                            end\n"
"                        end\n"
"                    end\n"
"                end\n"
"\n"
"                if slider_lo.rtype == \"slider\" then\n"
"                    ass_draw_rr_h_cw(elem_ass, foH - innerH / 6, foH - innerH / 6,\n"
"                                     xp, foH + innerH / 6,\n"
"                                     innerH / 6, slider_lo.stype == \"diamond\", 0)\n"
"                    ass_draw_rr_h_cw(elem_ass, xp, foH - innerH / 15,\n"
"                                     elem_geo.w - foH + innerH / 15, foH + innerH / 15,\n"
"                                     0, slider_lo.stype == \"diamond\", innerH / 15)\n"
"                    for _,range in pairs(seekRanges or {}) do\n"
"                        local pstart = get_slider_ele_pos_for(element, range[\"start\"])\n"
"                        local pend = get_slider_ele_pos_for(element, range[\"end\"])\n"
"                        ass_draw_rr_h_ccw(elem_ass, pstart, foH - innerH / 21,\n"
"                                          pend, foH + innerH / 21,\n"
"                                          innerH / 21, slider_lo.stype == \"diamond\")\n"
"                    end\n"
"                end\n"
"            end\n"
"\n"
"            if seekRanges then\n"
"                if slider_lo.rtype ~= \"inverted\" then\n"
"                    elem_ass:draw_stop()\n"
"                    elem_ass:merge(element.style_ass)\n"
"                    ass_append_alpha(elem_ass, element.layout.alpha, user_opts.seekrangealpha)\n"
"                    elem_ass:merge(element.static_ass)\n"
"                end\n"
"\n"
"                for _,range in pairs(seekRanges) do\n"
"                    local pstart = get_slider_ele_pos_for(element, range[\"start\"])\n"
"                    local pend = get_slider_ele_pos_for(element, range[\"end\"])\n"
"\n"
"                    if slider_lo.rtype == \"slider\" then\n"
"                        ass_draw_rr_h_cw(elem_ass, pstart, foH - innerH / 21,\n"
"                                         pend, foH + innerH / 21,\n"
"                                         innerH / 21, slider_lo.stype == \"diamond\")\n"
"                    elseif slider_lo.rtype == \"line\" then\n"
"                        if slider_lo.stype == \"bar\" then\n"
"                            elem_ass:rect_cw(pstart, elem_geo.h - foV - seekRangeLineHeight, pend, elem_geo.h - foV)\n"
"                        else\n"
"                            ass_draw_rr_h_cw(elem_ass, pstart - innerH / 8, foH - innerH / 8,\n"
"                                             pend + innerH / 8, foH + innerH / 8,\n"
"                                             innerH / 8, slider_lo.stype == \"diamond\")\n"
"                        end\n"
"                    elseif slider_lo.rtype == \"bar\" then\n"
"                        if slider_lo.stype ~= \"bar\" then\n"
"                            ass_draw_rr_h_cw(elem_ass, pstart - innerH / 2, foV,\n"
"                                             pend + innerH / 2, foV + innerH,\n"
"                                             innerH / 2, slider_lo.stype == \"diamond\")\n"
"                        elseif range[\"end\"] >= (pos or 0) then\n"
"                            elem_ass:rect_cw(pstart, foV, pend, elem_geo.h - foV)\n"
"                        else\n"
"                            elem_ass:rect_cw(pstart, elem_geo.h - foV - seekRangeLineHeight, pend, elem_geo.h - foV)\n"
"                        end\n"
"                    elseif slider_lo.rtype == \"inverted\" then\n"
"                        if slider_lo.stype ~= \"bar\" then\n"
"                            ass_draw_rr_h_ccw(elem_ass, pstart, (elem_geo.h / 2) - 1, pend,\n"
"                                              (elem_geo.h / 2) + 1,\n"
"                                              1, slider_lo.stype == \"diamond\")\n"
"                        else\n"
"                            elem_ass:rect_ccw(pstart, (elem_geo.h / 2) - 1, pend, (elem_geo.h / 2) + 1)\n"
"                        end\n"
"                    end\n"
"                end\n"
"            end\n"
"\n"
"            elem_ass:draw_stop()\n"
"\n"
"            -- add tooltip\n"
"            if not (element.slider.tooltipF == nil) then\n"
"\n"
"                if mouse_hit(element) then\n"
"                    local sliderpos = get_slider_value(element)\n"
"                    local tooltiplabel = element.slider.tooltipF(sliderpos)\n"
"\n"
"                    local an = slider_lo.tooltip_an\n"
"\n"
"                    local ty\n"
"\n"
"                    if (an == 2) then\n"
"                        ty = element.hitbox.y1 - slider_lo.border\n"
"                    else\n"
"                        ty = element.hitbox.y1 + elem_geo.h/2\n"
"                    end\n"
"\n"
"                    local tx = get_virt_mouse_pos()\n"
"                    if (slider_lo.adjust_tooltip) then\n"
"                        if (an == 2) then\n"
"                            if (sliderpos < (s_min + 3)) then\n"
"                                an = an - 1\n"
"                            elseif (sliderpos > (s_max - 3)) then\n"
"                                an = an + 1\n"
"                            end\n"
"                        elseif (sliderpos > (s_max-s_min)/2) then\n"
"                            an = an + 1\n"
"                            tx = tx - 5\n"
"                        else\n"
"                            an = an - 1\n"
"                            tx = tx + 10\n"
"                        end\n"
"                    end\n"
"\n"
"                    -- tooltip label\n"
"                    elem_ass:new_event()\n"
"                    elem_ass:pos(tx, ty)\n"
"                    elem_ass:an(an)\n"
"                    elem_ass:append(slider_lo.tooltip_style)\n"
"                    ass_append_alpha(elem_ass, slider_lo.alpha, 0)\n"
"                    elem_ass:append(tooltiplabel)\n"
"\n"
"                end\n"
"            end\n"
"\n"
"        elseif (element.type == \"button\") then\n"
"\n"
"            local buttontext\n"
"            if type(element.content) == \"function\" then\n"
"                buttontext = element.content() -- function objects\n"
"            elseif not (element.content == nil) then\n"
"                buttontext = element.content -- text objects\n"
"            end\n"
"\n"
"            local maxchars = element.layout.button.maxchars\n"
"            if not (maxchars == nil) and (#buttontext > maxchars) then\n"
"                local max_ratio = 1.25  -- up to 25% more chars while shrinking\n"
"                local limit = math.max(0, math.floor(maxchars * max_ratio) - 3)\n"
"                if (#buttontext > limit) then\n"
"                    while (#buttontext > limit) do\n"
"                        buttontext = buttontext:gsub(\".[\\128-\\191]*\044\", \"\")\n"
"                    end\n"
"                    buttontext = buttontext .. \"...\"\n"
"                end\n"
"                local _, nchars2 = buttontext:gsub(\".[\\128-\\191]*\", \"\")\n"
"                local stretch = (maxchars/#buttontext)*100\n"
"                buttontext = string.format(\"{\\\\fscx%f}\",\n"
"                    (maxchars/#buttontext)*100) .. buttontext\n"
"            end\n"
"\n"
"            elem_ass:append(buttontext)\n"
"        end\n"
"\n"
"        master_ass:merge(elem_ass)\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Message display\n"
"--\n"
"\n"
"-- pos is 1 based\n"
"function limited_list(prop, pos)\n"
"    local proplist = mp.get_property_native(prop, {})\n"
"    local count = #proplist\n"
"    if count == 0 then\n"
"        return count, proplist\n"
"    end\n"
"\n"
"    local fs = tonumber(mp.get_property('options/osd-font-size'))\n"
"    local max = math.ceil(osc_param.unscaled_y*0.75 / fs)\n"
"    if max % 2 == 0 then\n"
"        max = max - 1\n"
"    end\n"
"    local delta = math.ceil(max / 2) - 1\n"
"    local begi = math.max(math.min(pos - delta, count - max + 1), 1)\n"
"    local endi = math.min(begi + max - 1, count)\n"
"\n"
"    local reslist = {}\n"
"    for i=begi, endi do\n"
"        local item = proplist[i]\n"
"        item.current = (i == pos) and true or nil\n"
"        table.insert(reslist, item)\n"
"    end\n"
"    return count, reslist\n"
"end\n"
"\n"
"function get_playlist()\n"
"    local pos = mp.get_property_number('playlist-pos', 0) + 1\n"
"    local count, limlist = limited_list('playlist', pos)\n"
"    if count == 0 then\n"
"        return 'Empty playlist.'\n"
"    end\n"
"\n"
"    local message = string.format('Playlist [%d/%d]:\\n', pos, count)\n"
"    for i, v in ipairs(limlist) do\n"
"        local title = v.title\n"
"        local _, filename = utils.split_path(v.filename)\n"
"        if title == nil then\n"
"            title = filename\n"
"        end\n"
"        message = string.format('%s %s %s\\n', message,\n"
"            (v.current and '\342\227\217' or '\342\227\213'), title)\n"
"    end\n"
"    return message\n"
"end\n"
"\n"
"function get_chapterlist()\n"
"    local pos = mp.get_property_number('chapter', 0) + 1\n"
"    local count, limlist = limited_list('chapter-list', pos)\n"
"    if count == 0 then\n"
"        return 'No chapters.'\n"
"    end\n"
"\n"
"    local message = string.format('Chapters [%d/%d]:\\n', pos, count)\n"
"    for i, v in ipairs(limlist) do\n"
"        local time = mp.format_time(v.time)\n"
"        local title = v.title\n"
"        if title == nil then\n"
"            title = string.format('Chapter %02d', i)\n"
"        end\n"
"        message = string.format('%s[%s] %s %s\\n', message, time,\n"
"            (v.current and '\342\227\217' or '\342\227\213'), title)\n"
"    end\n"
"    return message\n"
"end\n"
"\n"
"function show_message(text, duration)\n"
"\n"
"    --print(\"text: \"..text..\"   duration: \" .. duration)\n"
"    if duration == nil then\n"
"        duration = tonumber(mp.get_property(\"options/osd-duration\")) / 1000\n"
"    elseif not type(duration) == \"number\" then\n"
"        print(\"duration: \" .. duration)\n"
"    end\n"
"\n"
"    -- cut the text short, otherwise the following functions\n"
"    -- may slow down massively on huge input\n"
"    text = string.sub(text, 0, 4000)\n"
"\n"
"    -- replace actual linebreaks with ASS linebreaks\n"
"    text = string.gsub(text, \"\\n\", \"\\\\N\")\n"
"\n"
"    state.message_text = text\n"
"    state.message_timeout = mp.get_time() + duration\n"
"end\n"
"\n"
"function render_message(ass)\n"
"    if not(state.message_timeout == nil) and not(state.message_text == nil)\n"
"        and state.message_timeout > mp.get_time() then\n"
"        local _, lines = string.gsub(state.message_text, \"\\\\N\", \"\")\n"
"\n"
"        local fontsize = tonumber(mp.get_property(\"options/osd-font-size\"))\n"
"        local outline = tonumber(mp.get_property(\"options/osd-border-size\"))\n"
"        local maxlines = math.ceil(osc_param.unscaled_y*0.75 / fontsize)\n"
"        local counterscale = osc_param.playresy / osc_param.unscaled_y\n"
"\n"
"        fontsize = fontsize * counterscale / math.max(0.65 + math.min(lines/maxlines, 1), 1)\n"
"        outline = outline * counterscale / math.max(0.75 + math.min(lines/maxlines, 1)/2, 1)\n"
"\n"
"        local style = \"{\\\\bord\" .. outline .. \"\\\\fs\" .. fontsize .. \"}\"\n"
"\n"
"\n"
"        ass:new_event()\n"
"        ass:append(style .. state.message_text)\n"
"    else\n"
"        state.message_text = nil\n"
"        state.message_timeout = nil\n"
"    end\n"
"end\n"
"\n"
"--\n"
"-- Initialisation and Layout\n"
"--\n"
"\n"
"function new_element(name, type)\n"
"    elements[name] = {}\n"
"    elements[name].type = type\n"
"\n"
"    -- add default stuff\n"
"    elements[name].eventresponder = {}\n"
"    elements[name].visible = true\n"
"    elements[name].enabled = true\n"
"    elements[name].softrepeat = false\n"
"    elements[name].styledown = (type == \"button\")\n"
"    elements[name].state = {}\n"
"\n"
"    if (type == \"slider\") then\n"
"        elements[name].slider = {min = {value = 0}, max = {value = 100}}\n"
"    end\n"
"\n"
"\n"
"    return elements[name]\n"
"end\n"
"\n"
"function add_layout(name)\n"
"    if not (elements[name] == nil) then\n"
"        -- new layout\n"
"        elements[name].layout = {}\n"
"\n"
"        -- set layout defaults\n"
"        elements[name].layout.layer = 50\n"
"        elements[name].layout.alpha = {[1] = 0, [2] = 255, [3] = 255, [4] = 255}\n"
"\n"
"        if (elements[name].type == \"button\") then\n"
"            elements[name].layout.button = {\n"
"                maxchars = nil,\n"
"            }\n"
"        elseif (elements[name].type == \"slider\") then\n"
"            -- slider defaults\n"
"            elements[name].layout.slider = {\n"
"                border = 1,\n"
"                gap = 1,\n"
"                nibbles_top = true,\n"
"                nibbles_bottom = true,\n"
"                stype = \"slider\",\n"
"                adjust_tooltip = true,\n"
"                tooltip_style = \"\",\n"
"                tooltip_an = 2,\n"
"                alpha = {[1] = 0, [2] = 255, [3] = 88, [4] = 255},\n"
"            }\n"
"        elseif (elements[name].type == \"box\") then\n"
"            elements[name].layout.box = {radius = 0, hexagon = false}\n"
"        end\n"
"\n"
"        return elements[name].layout\n"
"    else\n"
"        msg.error(\"Can't add_layout to element \\\"\"..name..\"\\\", doesn't exist.\")\n"
"    end\n"
"end\n"
"\n"
"-- Window Controls\n"
"function window_controls(topbar)\n"
"    local wc_geo = {\n"
"        x = 0,\n"
"        y = 30 + user_opts.barmargin,\n"
"        an = 1,\n"
"        w = osc_param.playresx,\n"
"        h = 30,\n"
"    }\n"
"\n"
"    local alignment = window_controls_alignment()\n"
"    local controlbox_w = window_control_box_width\n"
"    local titlebox_w = wc_geo.w - controlbox_w\n"
"\n"
"    -- Default alignment is \"right\"\n"
"    local controlbox_left = wc_geo.w - controlbox_w\n"
"    local titlebox_left = wc_geo.x + 5\n"
"\n"
"    if alignment == \"left\" then\n"
"        controlbox_left = wc_geo.x\n"
"        titlebox_left = wc_geo.x + controlbox_w + 5\n"
"    end\n"
"\n"
"    add_area(\"window-controls\",\n"
"             get_hitbox_coords(controlbox_left, wc_geo.y, wc_geo.an,\n"
"                               controlbox_w, wc_geo.h))\n"
"\n"
"    local lo\n"
"\n"
"    -- Background Bar\n"
"    new_element(\"wcbar\", \"box\")\n"
"    lo = add_layout(\"wcbar\")\n"
"    lo.geometry = wc_geo\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.wcBar\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"\n"
"    local button_y = wc_geo.y - (wc_geo.h / 2)\n"
"    local first_geo =\n"
"        {x = controlbox_left + 5, y = button_y, an = 4, w = 25, h = 25}\n"
"    local second_geo =\n"
"        {x = controlbox_left + 30, y = button_y, an = 4, w = 25, h = 25}\n"
"    local third_geo =\n"
"        {x = controlbox_left + 55, y = button_y, an = 4, w = 25, h = 25}\n"
"\n"
"    -- Window control buttons use symbols in the custom mpv osd font\n"
"    -- because the official unicode codepoints are sufficiently\n"
"    -- exotic that a system might lack an installed font with them,\n"
"    -- and libass will complain that they are not present in the\n"
"    -- default font, even if another font with them is available.\n"
"\n"
"    -- Close: \360\237\227\231\n"
"    ne = new_element(\"close\", \"button\")\n"
"    ne.content = \"\\238\\132\\149\"\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"quit\") end\n"
"    lo = add_layout(\"close\")\n"
"    lo.geometry = alignment == \"left\" and first_geo or third_geo\n"
"    lo.style = osc_styles.wcButtons\n"
"\n"
"    -- Minimize: \360\237\227\225\n"
"    ne = new_element(\"minimize\", \"button\")\n"
"    ne.content = \"\\238\\132\\146\"\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"window-minimized\") end\n"
"    lo = add_layout(\"minimize\")\n"
"    lo.geometry = alignment == \"left\" and second_geo or first_geo\n"
"    lo.style = osc_styles.wcButtons\n"
"\n"
"    -- Maximize: \360\237\227\226 /\360\237\227\227\n"
"    ne = new_element(\"maximize\", \"button\")\n"
"    if state.maximized then\n"
"        ne.content = \"\\238\\132\\148\"\n"
"    else\n"
"        ne.content = \"\\238\\132\\147\"\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"window-maximized\") end\n"
"    lo = add_layout(\"maximize\")\n"
"    lo.geometry = alignment == \"left\" and third_geo or second_geo\n"
"    lo.style = osc_styles.wcButtons\n"
"\n"
"    -- deadzone below window controls\n"
"    local sh_area_y0, sh_area_y1\n"
"    sh_area_y0 = user_opts.barmargin\n"
"    sh_area_y1 = (wc_geo.y + (wc_geo.h / 2)) +\n"
"                 get_align(1 - (2 * user_opts.deadzonesize),\n"
"                 osc_param.playresy - (wc_geo.y + (wc_geo.h / 2)), 0, 0)\n"
"    add_area(\"showhide_wc\", wc_geo.x, sh_area_y0, wc_geo.w, sh_area_y1)\n"
"\n"
"    if topbar then\n"
"        -- The title is already there as part of the top bar\n"
"        return\n"
"    else\n"
"        -- Apply boxvideo margins to the control bar\n"
"        osc_param.video_margins.t = wc_geo.h / osc_param.playresy\n"
"    end\n"
"\n"
"    -- Window Title\n"
"    ne = new_element(\"wctitle\", \"button\")\n"
"    ne.content = function ()\n"
"        local title = mp.command_native({\"expand-text\", user_opts.title})\n"
"        -- escape ASS, and strip newlines and trailing slashes\n"
"        title = title:gsub(\"\\\\n\", \" \"):gsub(\"\\\\\044\", \"\"):gsub(\"{\",\"\\\\{\")\n"
"        return not (title == \"\") and title or \"mpv\"\n"
"    end\n"
"    lo = add_layout(\"wctitle\")\n"
"    lo.geometry =\n"
"        { x = titlebox_left, y = wc_geo.y - 3, an = 1, w = titlebox_w, h = wc_geo.h }\n"
"    lo.style = string.format(\"%s{\\\\clip(%f,%f,%f,%f)}\",\n"
"        osc_styles.wcTitle,\n"
"        titlebox_left, wc_geo.y - wc_geo.h, titlebox_w, wc_geo.y + wc_geo.h)\n"
"end\n"
"\n"
"--\n"
"-- Layouts\n"
"--\n"
"\n"
"local layouts = {}\n"
"\n"
"-- Classic box layout\n"
"layouts[\"box\"] = function ()\n"
"\n"
"    local osc_geo = {\n"
"        w = 550,    -- width\n"
"        h = 138,    -- height\n"
"        r = 10,     -- corner-radius\n"
"        p = 15,     -- padding\n"
"    }\n"
"\n"
"    -- make sure the OSC actually fits into the video\n"
"    if (osc_param.playresx < (osc_geo.w + (2 * osc_geo.p))) then\n"
"        osc_param.playresy = (osc_geo.w+(2*osc_geo.p))/osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"    end\n"
"\n"
"    -- position of the controller according to video aspect and valignment\n"
"    local posX = math.floor(get_align(user_opts.halign, osc_param.playresx,\n"
"        osc_geo.w, 0))\n"
"    local posY = math.floor(get_align(user_opts.valign, osc_param.playresy,\n"
"        osc_geo.h, 0))\n"
"\n"
"    -- position offset for contents aligned at the borders of the box\n"
"    local pos_offsetX = (osc_geo.w - (2*osc_geo.p)) / 2\n"
"    local pos_offsetY = (osc_geo.h - (2*osc_geo.p)) / 2\n"
"\n"
"    osc_param.areas = {} -- delete areas\n"
"\n"
"    -- area for active mouse input\n"
"    add_area(\"input\", get_hitbox_coords(posX, posY, 5, osc_geo.w, osc_geo.h))\n"
"\n"
"    -- area for show/hide\n"
"    local sh_area_y0, sh_area_y1\n"
"    if user_opts.valign > 0 then\n"
"        -- deadzone above OSC\n"
"        sh_area_y0 = get_align(-1 + (2*user_opts.deadzonesize),\n"
"            posY - (osc_geo.h / 2), 0, 0)\n"
"        sh_area_y1 = osc_param.playresy\n"
"    else\n"
"        -- deadzone below OSC\n"
"        sh_area_y0 = 0\n"
"        sh_area_y1 = (posY + (osc_geo.h / 2)) +\n"
"            get_align(1 - (2*user_opts.deadzonesize),\n"
"            osc_param.playresy - (posY + (osc_geo.h / 2)), 0, 0)\n"
"    end\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    -- fetch values\n"
"    local osc_w, osc_h, osc_r, osc_p =\n"
"        osc_geo.w, osc_geo.h, osc_geo.r, osc_geo.p\n"
"\n"
"    local lo\n"
"\n"
"    --\n"
"    -- Background box\n"
"    --\n"
"\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = {x = posX, y = posY, an = 5, w = osc_w, h = osc_h}\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"    lo.box.radius = osc_r\n"
"\n"
"    --\n"
"    -- Title row\n"
"    --\n"
"\n"
"    local titlerowY = posY - pos_offsetY - 10\n"
"\n"
"    lo = add_layout(\"title\")\n"
"    lo.geometry = {x = posX, y = titlerowY, an = 8, w = 496, h = 12}\n"
"    lo.style = osc_styles.vidtitle\n"
"    lo.button.maxchars = user_opts.boxmaxchars\n"
"\n"
"    lo = add_layout(\"pl_prev\")\n"
"    lo.geometry =\n"
"        {x = (posX - pos_offsetX), y = titlerowY, an = 7, w = 12, h = 12}\n"
"    lo.style = osc_styles.topButtons\n"
"\n"
"    lo = add_layout(\"pl_next\")\n"
"    lo.geometry =\n"
"        {x = (posX + pos_offsetX), y = titlerowY, an = 9, w = 12, h = 12}\n"
"    lo.style = osc_styles.topButtons\n"
"\n"
"    --\n"
"    -- Big buttons\n"
"    --\n"
"\n"
"    local bigbtnrowY = posY - pos_offsetY + 35\n"
"    local bigbtndist = 60\n"
"\n"
"    lo = add_layout(\"playpause\")\n"
"    lo.geometry =\n"
"        {x = posX, y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"skipback\")\n"
"    lo.geometry =\n"
"        {x = posX - bigbtndist, y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"skipfrwd\")\n"
"    lo.geometry =\n"
"        {x = posX + bigbtndist, y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"ch_prev\")\n"
"    lo.geometry =\n"
"        {x = posX - (bigbtndist * 2), y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"ch_next\")\n"
"    lo.geometry =\n"
"        {x = posX + (bigbtndist * 2), y = bigbtnrowY, an = 5, w = 40, h = 40}\n"
"    lo.style = osc_styles.bigButtons\n"
"\n"
"    lo = add_layout(\"cy_audio\")\n"
"    lo.geometry =\n"
"        {x = posX - pos_offsetX, y = bigbtnrowY, an = 1, w = 70, h = 18}\n"
"    lo.style = osc_styles.smallButtonsL\n"
"\n"
"    lo = add_layout(\"cy_sub\")\n"
"    lo.geometry =\n"
"        {x = posX - pos_offsetX, y = bigbtnrowY, an = 7, w = 70, h = 18}\n"
"    lo.style = osc_styles.smallButtonsL\n"
"\n"
"    lo = add_layout(\"tog_fs\")\n"
"    lo.geometry =\n"
"        {x = posX+pos_offsetX - 25, y = bigbtnrowY, an = 4, w = 25, h = 25}\n"
"    lo.style = osc_styles.smallButtonsR\n"
"\n"
"    lo = add_layout(\"volume\")\n"
"    lo.geometry =\n"
"        {x = posX+pos_offsetX - (25 * 2) - osc_geo.p,\n"
"         y = bigbtnrowY, an = 4, w = 25, h = 25}\n"
"    lo.style = osc_styles.smallButtonsR\n"
"\n"
"    --\n"
"    -- Seekbar\n"
"    --\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry =\n"
"        {x = posX, y = posY+pos_offsetY-22, an = 2, w = pos_offsetX*2, h = 15}\n"
"    lo.style = osc_styles.timecodes\n"
"    lo.slider.tooltip_style = osc_styles.vidtitle\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"    lo.slider.rtype = user_opts[\"seekrangestyle\"]\n"
"\n"
"    --\n"
"    -- Timecodes + Cache\n"
"    --\n"
"\n"
"    local bottomrowY = posY + pos_offsetY - 5\n"
"\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry =\n"
"        {x = posX - pos_offsetX, y = bottomrowY, an = 4, w = 110, h = 18}\n"
"    lo.style = osc_styles.timecodes\n"
"\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry =\n"
"        {x = posX + pos_offsetX, y = bottomrowY, an = 6, w = 110, h = 18}\n"
"    lo.style = osc_styles.timecodes\n"
"\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry =\n"
"        {x = posX, y = bottomrowY, an = 5, w = 110, h = 18}\n"
"    lo.style = osc_styles.timecodes\n"
"\n"
"end\n"
"\n"
"-- slim box layout\n"
"layouts[\"slimbox\"] = function ()\n"
"\n"
"    local osc_geo = {\n"
"        w = 660,    -- width\n"
"        h = 70,     -- height\n"
"        r = 10,     -- corner-radius\n"
"    }\n"
"\n"
"    -- make sure the OSC actually fits into the video\n"
"    if (osc_param.playresx < (osc_geo.w)) then\n"
"        osc_param.playresy = (osc_geo.w)/osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"    end\n"
"\n"
"    -- position of the controller according to video aspect and valignment\n"
"    local posX = math.floor(get_align(user_opts.halign, osc_param.playresx,\n"
"        osc_geo.w, 0))\n"
"    local posY = math.floor(get_align(user_opts.valign, osc_param.playresy,\n"
"        osc_geo.h, 0))\n"
"\n"
"    osc_param.areas = {} -- delete areas\n"
"\n"
"    -- area for active mouse input\n"
"    add_area(\"input\", get_hitbox_coords(posX, posY, 5, osc_geo.w, osc_geo.h))\n"
"\n"
"    -- area for show/hide\n"
"    local sh_area_y0, sh_area_y1\n"
"    if user_opts.valign > 0 then\n"
"        -- deadzone above OSC\n"
"        sh_area_y0 = get_align(-1 + (2*user_opts.deadzonesize),\n"
"            posY - (osc_geo.h / 2), 0, 0)\n"
"        sh_area_y1 = osc_param.playresy\n"
"    else\n"
"        -- deadzone below OSC\n"
"        sh_area_y0 = 0\n"
"        sh_area_y1 = (posY + (osc_geo.h / 2)) +\n"
"            get_align(1 - (2*user_opts.deadzonesize),\n"
"            osc_param.playresy - (posY + (osc_geo.h / 2)), 0, 0)\n"
"    end\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    local lo\n"
"\n"
"    local tc_w, ele_h, inner_w = 100, 20, osc_geo.w - 100\n"
"\n"
"    -- styles\n"
"    local styles = {\n"
"        box = \"{\\\\rDefault\\\\blur0\\\\bord1\\\\1c&H000000\\\\3c&HFFFFFF}\",\n"
"        timecodes = \"{\\\\1c&HFFFFFF\\\\3c&H000000\\\\fs20\\\\bord2\\\\blur1}\",\n"
"        tooltip = \"{\\\\1c&HFFFFFF\\\\3c&H000000\\\\fs12\\\\bord1\\\\blur0.5}\",\n"
"    }\n"
"\n"
"\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = {x = posX, y = posY - 1, an = 2, w = inner_w, h = ele_h}\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"    lo.alpha[3] = 0\n"
"    if not (user_opts[\"seekbarstyle\"] == \"bar\") then\n"
"        lo.box.radius = osc_geo.r\n"
"        lo.box.hexagon = user_opts[\"seekbarstyle\"] == \"diamond\"\n"
"    end\n"
"\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry =\n"
"        {x = posX, y = posY - 1, an = 2, w = inner_w, h = ele_h}\n"
"    lo.style = osc_styles.timecodes\n"
"    lo.slider.border = 0\n"
"    lo.slider.gap = 1.5\n"
"    lo.slider.tooltip_style = styles.tooltip\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"    lo.slider.rtype = user_opts[\"seekrangestyle\"]\n"
"    lo.slider.adjust_tooltip = false\n"
"\n"
"    --\n"
"    -- Timecodes\n"
"    --\n"
"\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry =\n"
"        {x = posX - (inner_w/2) + osc_geo.r, y = posY + 1,\n"
"        an = 7, w = tc_w, h = ele_h}\n"
"    lo.style = styles.timecodes\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry =\n"
"        {x = posX + (inner_w/2) - osc_geo.r, y = posY + 1,\n"
"        an = 9, w = tc_w, h = ele_h}\n"
"    lo.style = styles.timecodes\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"\n"
"    -- Cache\n"
"\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry =\n"
"        {x = posX, y = posY + 1,\n"
"        an = 8, w = tc_w, h = ele_h}\n"
"    lo.style = styles.timecodes\n"
"    lo.alpha[3] = user_opts.boxalpha\n"
"\n"
"\n"
"end\n"
"\n"
"function bar_layout(direction)\n"
"    local osc_geo = {\n"
"        x = -2,\n"
"        y,\n"
"        an = (direction < 0) and 7 or 1,\n"
"        w,\n"
"        h = 56,\n"
"    }\n"
"\n"
"    local padX = 9\n"
"    local padY = 3\n"
"    local buttonW = 27\n"
"    local tcW = (state.tc_ms) and 170 or 110\n"
"    local tsW = 90\n"
"    local minW = (buttonW + padX)*5 + (tcW + padX)*4 + (tsW + padX)*2\n"
"\n"
"    -- Special topbar handling when window controls are present\n"
"    local padwc_l\n"
"    local padwc_r\n"
"    if direction < 0 or not window_controls_enabled() then\n"
"        padwc_l = 0\n"
"        padwc_r = 0\n"
"    elseif window_controls_alignment() == \"left\" then\n"
"        padwc_l = window_control_box_width\n"
"        padwc_r = 0\n"
"    else\n"
"        padwc_l = 0\n"
"        padwc_r = window_control_box_width\n"
"    end\n"
"\n"
"    if ((osc_param.display_aspect > 0) and (osc_param.playresx < minW)) then\n"
"        osc_param.playresy = minW / osc_param.display_aspect\n"
"        osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"    end\n"
"\n"
"    osc_geo.y = direction * (54 + user_opts.barmargin)\n"
"    osc_geo.w = osc_param.playresx + 4\n"
"    if direction < 0 then\n"
"        osc_geo.y = osc_geo.y + osc_param.playresy\n"
"    end\n"
"\n"
"    local line1 = osc_geo.y - direction * (9 + padY)\n"
"    local line2 = osc_geo.y - direction * (36 + padY)\n"
"\n"
"    osc_param.areas = {}\n"
"\n"
"    add_area(\"input\", get_hitbox_coords(osc_geo.x, osc_geo.y, osc_geo.an,\n"
"                                        osc_geo.w, osc_geo.h))\n"
"\n"
"    local sh_area_y0, sh_area_y1\n"
"    if direction > 0 then\n"
"        -- deadzone below OSC\n"
"        sh_area_y0 = user_opts.barmargin\n"
"        sh_area_y1 = (osc_geo.y + (osc_geo.h / 2)) +\n"
"                     get_align(1 - (2*user_opts.deadzonesize),\n"
"                     osc_param.playresy - (osc_geo.y + (osc_geo.h / 2)), 0, 0)\n"
"    else\n"
"        -- deadzone above OSC\n"
"        sh_area_y0 = get_align(-1 + (2*user_opts.deadzonesize),\n"
"                               osc_geo.y - (osc_geo.h / 2), 0, 0)\n"
"        sh_area_y1 = osc_param.playresy - user_opts.barmargin\n"
"    end\n"
"    add_area(\"showhide\", 0, sh_area_y0, osc_param.playresx, sh_area_y1)\n"
"\n"
"    local lo, geo\n"
"\n"
"    -- Background bar\n"
"    new_element(\"bgbox\", \"box\")\n"
"    lo = add_layout(\"bgbox\")\n"
"\n"
"    lo.geometry = osc_geo\n"
"    lo.layer = 10\n"
"    lo.style = osc_styles.box\n"
"    lo.alpha[1] = user_opts.boxalpha\n"
"\n"
"\n"
"    -- Playlist prev/next\n"
"    geo = { x = osc_geo.x + padX, y = line1,\n"
"            an = 4, w = 18, h = 18 - padY }\n"
"    lo = add_layout(\"pl_prev\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.topButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"pl_next\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.topButtonsBar\n"
"\n"
"    local t_l = geo.x + geo.w + padX\n"
"\n"
"    -- Cache\n"
"    geo = { x = osc_geo.x + osc_geo.w - padX, y = geo.y,\n"
"            an = 6, w = 150, h = geo.h }\n"
"    lo = add_layout(\"cache\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.vidtitleBar\n"
"\n"
"    local t_r = geo.x - geo.w - padX*2\n"
"\n"
"    -- Title\n"
"    geo = { x = t_l, y = geo.y, an = 4,\n"
"            w = t_r - t_l, h = geo.h }\n"
"    lo = add_layout(\"title\")\n"
"    lo.geometry = geo\n"
"    lo.style = string.format(\"%s{\\\\clip(%f,%f,%f,%f)}\",\n"
"        osc_styles.vidtitleBar,\n"
"        geo.x, geo.y-geo.h, geo.w, geo.y+geo.h)\n"
"\n"
"\n"
"    -- Playback control buttons\n"
"    geo = { x = osc_geo.x + padX + padwc_l, y = line2, an = 4,\n"
"            w = buttonW, h = 36 - padY*2}\n"
"    lo = add_layout(\"playpause\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"ch_prev\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x + geo.w + padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"ch_next\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Left timecode\n"
"    geo = { x = geo.x + geo.w + padX + tcW, y = geo.y, an = 6,\n"
"            w = tcW, h = geo.h }\n"
"    lo = add_layout(\"tc_left\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"\n"
"    local sb_l = geo.x + padX\n"
"\n"
"    -- Fullscreen button\n"
"    geo = { x = osc_geo.x + osc_geo.w - buttonW - padX - padwc_r, y = geo.y, an = 4,\n"
"            w = buttonW, h = geo.h }\n"
"    lo = add_layout(\"tog_fs\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Volume\n"
"    geo = { x = geo.x - geo.w - padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"volume\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    -- Track selection buttons\n"
"    geo = { x = geo.x - tsW - padX, y = geo.y, an = geo.an, w = tsW, h = geo.h }\n"
"    lo = add_layout(\"cy_sub\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"    geo = { x = geo.x - geo.w - padX, y = geo.y, an = geo.an, w = geo.w, h = geo.h }\n"
"    lo = add_layout(\"cy_audio\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.smallButtonsBar\n"
"\n"
"\n"
"    -- Right timecode\n"
"    geo = { x = geo.x - padX - tcW - 10, y = geo.y, an = geo.an,\n"
"            w = tcW, h = geo.h }\n"
"    lo = add_layout(\"tc_right\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"\n"
"    local sb_r = geo.x - padX\n"
"\n"
"\n"
"    -- Seekbar\n"
"    geo = { x = sb_l, y = geo.y, an = geo.an,\n"
"            w = math.max(0, sb_r - sb_l), h = geo.h }\n"
"    new_element(\"bgbar1\", \"box\")\n"
"    lo = add_layout(\"bgbar1\")\n"
"\n"
"    lo.geometry = geo\n"
"    lo.layer = 15\n"
"    lo.style = osc_styles.timecodesBar\n"
"    lo.alpha[1] =\n"
"        math.min(255, user_opts.boxalpha + (255 - user_opts.boxalpha)*0.8)\n"
"    if not (user_opts[\"seekbarstyle\"] == \"bar\") then\n"
"        lo.box.radius = geo.h / 2\n"
"        lo.box.hexagon = user_opts[\"seekbarstyle\"] == \"diamond\"\n"
"    end\n"
"\n"
"    lo = add_layout(\"seekbar\")\n"
"    lo.geometry = geo\n"
"    lo.style = osc_styles.timecodesBar\n"
"    lo.slider.border = 0\n"
"    lo.slider.gap = 2\n"
"    lo.slider.tooltip_style = osc_styles.timePosBar\n"
"    lo.slider.tooltip_an = 5\n"
"    lo.slider.stype = user_opts[\"seekbarstyle\"]\n"
"    lo.slider.rtype = user_opts[\"seekrangestyle\"]\n"
"\n"
"    if direction < 0 then\n"
"        osc_param.video_margins.b = osc_geo.h / osc_param.playresy\n"
"    else\n"
"        osc_param.video_margins.t = osc_geo.h / osc_param.playresy\n"
"    end\n"
"end\n"
"\n"
"layouts[\"bottombar\"] = function()\n"
"    bar_layout(-1)\n"
"end\n"
"\n"
"layouts[\"topbar\"] = function()\n"
"    bar_layout(1)\n"
"end\n"
"\n"
"-- Validate string type user options\n"
"function validate_user_opts()\n"
"    if layouts[user_opts.layout] == nil then\n"
"        msg.warn(\"Invalid setting \\\"\"..user_opts.layout..\"\\\" for layout\")\n"
"        user_opts.layout = \"bottombar\"\n"
"    end\n"
"\n"
"    if user_opts.seekbarstyle ~= \"bar\" and\n"
"       user_opts.seekbarstyle ~= \"diamond\" and\n"
"       user_opts.seekbarstyle ~= \"knob\" then\n"
"        msg.warn(\"Invalid setting \\\"\" .. user_opts.seekbarstyle\n"
"            .. \"\\\" for seekbarstyle\")\n"
"        user_opts.seekbarstyle = \"bar\"\n"
"    end\n"
"\n"
"    if user_opts.seekrangestyle ~= \"bar\" and\n"
"       user_opts.seekrangestyle ~= \"line\" and\n"
"       user_opts.seekrangestyle ~= \"slider\" and\n"
"       user_opts.seekrangestyle ~= \"inverted\" and\n"
"       user_opts.seekrangestyle ~= \"none\" then\n"
"        msg.warn(\"Invalid setting \\\"\" .. user_opts.seekrangestyle\n"
"            .. \"\\\" for seekrangestyle\")\n"
"        user_opts.seekrangestyle = \"inverted\"\n"
"    end\n"
"\n"
"    if user_opts.seekrangestyle == \"slider\" and\n"
"       user_opts.seekbarstyle == \"bar\" then\n"
"        msg.warn(\"Using \\\"slider\\\" seekrangestyle together with \\\"bar\\\" seekbarstyle is not supported\")\n"
"        user_opts.seekrangestyle = \"inverted\"\n"
"    end\n"
"\n"
"    if user_opts.windowcontrols ~= \"auto\" and\n"
"       user_opts.windowcontrols ~= \"yes\" and\n"
"       user_opts.windowcontrols ~= \"no\" then\n"
"        msg.warn(\"windowcontrols cannot be \\\"\" ..\n"
"                user_opts.windowcontrols .. \"\\\". Ignoring.\")\n"
"        user_opts.windowcontrols = \"auto\"\n"
"    end\n"
"    if user_opts.windowcontrols_alignment ~= \"right\" and\n"
"       user_opts.windowcontrols_alignment ~= \"left\" then\n"
"        msg.warn(\"windowcontrols_alignment cannot be \\\"\" ..\n"
"                user_opts.windowcontrols_alignment .. \"\\\". Ignoring.\")\n"
"        user_opts.windowcontrols_alignment = \"right\"\n"
"    end\n"
"end\n"
"\n"
"function update_options(list)\n"
"    validate_user_opts()\n"
"    request_tick()\n"
"    visibility_mode(user_opts.visibility, true)\n"
"    request_init()\n"
"end\n"
"\n"
"-- OSC INIT\n"
"function osc_init()\n"
"    msg.debug(\"osc_init\")\n"
"\n"
"    -- set canvas resolution according to display aspect and scaling setting\n"
"    local baseResY = 720\n"
"    local display_w, display_h, display_aspect = mp.get_osd_size()\n"
"    local scale = 1\n"
"\n"
"    if (mp.get_property(\"video\") == \"no\") then -- dummy/forced window\n"
"        scale = user_opts.scaleforcedwindow\n"
"    elseif state.fullscreen then\n"
"        scale = user_opts.scalefullscreen\n"
"    else\n"
"        scale = user_opts.scalewindowed\n"
"    end\n"
"\n"
"    if user_opts.vidscale then\n"
"        osc_param.unscaled_y = baseResY\n"
"    else\n"
"        osc_param.unscaled_y = display_h\n"
"    end\n"
"    osc_param.playresy = osc_param.unscaled_y / scale\n"
"    if (display_aspect > 0) then\n"
"        osc_param.display_aspect = display_aspect\n"
"    end\n"
"    osc_param.playresx = osc_param.playresy * osc_param.display_aspect\n"
"\n"
"    -- stop seeking with the slider to prevent skipping files\n"
"    state.active_element = nil\n"
"\n"
"    osc_param.video_margins = {l = 0, r = 0, t = 0, b = 0}\n"
"\n"
"    elements = {}\n"
"\n"
"    -- some often needed stuff\n"
"    local pl_count = mp.get_property_number(\"playlist-count\", 0)\n"
"    local have_pl = (pl_count > 1)\n"
"    local pl_pos = mp.get_property_number(\"playlist-pos\", 0) + 1\n"
"    local have_ch = (mp.get_property_number(\"chapters\", 0) > 0)\n"
"    local loop = mp.get_property(\"loop-playlist\", \"no\")\n"
"\n"
"    local ne\n"
"\n"
"    -- title\n"
"    ne = new_element(\"title\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        local title = mp.command_native({\"expand-text\", user_opts.title})\n"
"        -- escape ASS, and strip newlines and trailing slashes\n"
"        title = title:gsub(\"\\\\n\", \" \"):gsub(\"\\\\\044\", \"\"):gsub(\"{\",\"\\\\{\")\n"
"        return not (title == \"\") and title or \"mpv\"\n"
"    end\n"
"\n"
"    ne.eventresponder[\"mbtn_left_up\"] = function ()\n"
"        local title = mp.get_property_osd(\"media-title\")\n"
"        if (have_pl) then\n"
"            title = string.format(\"[%d/%d] %s\", countone(pl_pos - 1),\n"
"                                  pl_count, title)\n"
"        end\n"
"        show_message(title)\n"
"    end\n"
"\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(mp.get_property_osd(\"filename\")) end\n"
"\n"
"    -- playlist buttons\n"
"\n"
"    -- prev\n"
"    ne = new_element(\"pl_prev\", \"button\")\n"
"\n"
"    ne.content = \"\\238\\132\\144\"\n"
"    ne.enabled = (pl_pos > 1) or (loop ~= \"no\")\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"playlist-prev\", \"weak\")\n"
"            show_message(get_playlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"\n"
"    --next\n"
"    ne = new_element(\"pl_next\", \"button\")\n"
"\n"
"    ne.content = \"\\238\\132\\129\"\n"
"    ne.enabled = (have_pl and (pl_pos < pl_count)) or (loop ~= \"no\")\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"playlist-next\", \"weak\")\n"
"            show_message(get_playlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_playlist(), 3) end\n"
"\n"
"\n"
"    -- big buttons\n"
"\n"
"    --playpause\n"
"    ne = new_element(\"playpause\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        if mp.get_property(\"pause\") == \"yes\" then\n"
"            return (\"\\238\\132\\129\")\n"
"        else\n"
"            return (\"\\238\\128\\130\")\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"pause\") end\n"
"\n"
"    --skipback\n"
"    ne = new_element(\"skipback\", \"button\")\n"
"\n"
"    ne.softrepeat = true\n"
"    ne.content = \"\\238\\128\\132\"\n"
"    ne.eventresponder[\"mbtn_left_down\"] =\n"
"        function () mp.commandv(\"seek\", -5, \"relative\", \"keyframes\") end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () mp.commandv(\"frame-back-step\") end\n"
"    ne.eventresponder[\"mbtn_right_down\"] =\n"
"        function () mp.commandv(\"seek\", -30, \"relative\", \"keyframes\") end\n"
"\n"
"    --skipfrwd\n"
"    ne = new_element(\"skipfrwd\", \"button\")\n"
"\n"
"    ne.softrepeat = true\n"
"    ne.content = \"\\238\\128\\133\"\n"
"    ne.eventresponder[\"mbtn_left_down\"] =\n"
"        function () mp.commandv(\"seek\", 10, \"relative\", \"keyframes\") end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () mp.commandv(\"frame-step\") end\n"
"    ne.eventresponder[\"mbtn_right_down\"] =\n"
"        function () mp.commandv(\"seek\", 60, \"relative\", \"keyframes\") end\n"
"\n"
"    --ch_prev\n"
"    ne = new_element(\"ch_prev\", \"button\")\n"
"\n"
"    ne.enabled = have_ch\n"
"    ne.content = \"\\238\\132\\132\"\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"add\", \"chapter\", -1)\n"
"            show_message(get_chapterlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"\n"
"    --ch_next\n"
"    ne = new_element(\"ch_next\", \"button\")\n"
"\n"
"    ne.enabled = have_ch\n"
"    ne.content = \"\\238\\132\\133\"\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function ()\n"
"            mp.commandv(\"add\", \"chapter\", 1)\n"
"            show_message(get_chapterlist(), 3)\n"
"        end\n"
"    ne.eventresponder[\"shift+mbtn_left_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () show_message(get_chapterlist(), 3) end\n"
"\n"
"    --\n"
"    update_tracklist()\n"
"\n"
"    --cy_audio\n"
"    ne = new_element(\"cy_audio\", \"button\")\n"
"\n"
"    ne.enabled = (#tracks_osc.audio > 0)\n"
"    ne.content = function ()\n"
"        local aid = \"\342\200\223\"\n"
"        if not (get_track(\"audio\") == 0) then\n"
"            aid = get_track(\"audio\")\n"
"        end\n"
"        return (\"\\238\\132\\134\" .. osc_styles.smallButtonsLlabel\n"
"            .. \" \" .. aid .. \"/\" .. #tracks_osc.audio)\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () set_track(\"audio\", 1) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () set_track(\"audio\", -1) end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () show_message(get_tracklist(\"audio\"), 2) end\n"
"\n"
"    --cy_sub\n"
"    ne = new_element(\"cy_sub\", \"button\")\n"
"\n"
"    ne.enabled = (#tracks_osc.sub > 0)\n"
"    ne.content = function ()\n"
"        local sid = \"\342\200\223\"\n"
"        if not (get_track(\"sub\") == 0) then\n"
"            sid = get_track(\"sub\")\n"
"        end\n"
"        return (\"\\238\\132\\135\" .. osc_styles.smallButtonsLlabel\n"
"            .. \" \" .. sid .. \"/\" .. #tracks_osc.sub)\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () set_track(\"sub\", 1) end\n"
"    ne.eventresponder[\"mbtn_right_up\"] =\n"
"        function () set_track(\"sub\", -1) end\n"
"    ne.eventresponder[\"shift+mbtn_left_down\"] =\n"
"        function () show_message(get_tracklist(\"sub\"), 2) end\n"
"\n"
"    --tog_fs\n"
"    ne = new_element(\"tog_fs\", \"button\")\n"
"    ne.content = function ()\n"
"        if (state.fullscreen) then\n"
"            return (\"\\238\\132\\137\")\n"
"        else\n"
"            return (\"\\238\\132\\136\")\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"fullscreen\") end\n"
"\n"
"    --seekbar\n"
"    ne = new_element(\"seekbar\", \"slider\")\n"
"\n"
"    ne.enabled = not (mp.get_property(\"percent-pos\") == nil)\n"
"    ne.slider.markerF = function ()\n"
"        local duration = mp.get_property_number(\"duration\", nil)\n"
"        if not (duration == nil) then\n"
"            local chapters = mp.get_property_native(\"chapter-list\", {})\n"
"            local markers = {}\n"
"            for n = 1, #chapters do\n"
"                markers[n] = (chapters[n].time / duration * 100)\n"
"            end\n"
"            return markers\n"
"        else\n"
"            return {}\n"
"        end\n"
"    end\n"
"    ne.slider.posF =\n"
"        function () return mp.get_property_number(\"percent-pos\", nil) end\n"
"    ne.slider.tooltipF = function (pos)\n"
"        local duration = mp.get_property_number(\"duration\", nil)\n"
"        if not ((duration == nil) or (pos == nil)) then\n"
"            possec = duration * (pos / 100)\n"
"            return mp.format_time(possec)\n"
"        else\n"
"            return \"\"\n"
"        end\n"
"    end\n"
"    ne.slider.seekRangesF = function()\n"
"        if user_opts.seekrangestyle == \"none\" then\n"
"            return nil\n"
"        end\n"
"        local cache_state = state.cache_state\n"
"        if not cache_state then\n"
"            return nil\n"
"        end\n"
"        local duration = mp.get_property_number(\"duration\", nil)\n"
"        if (duration == nil) or duration <= 0 then\n"
"            return nil\n"
"        end\n"
"        local ranges = cache_state[\"seekable-ranges\"]\n"
"        if #ranges == 0 then\n"
"            return nil\n"
"        end\n"
"        local nranges = {}\n"
"        for _, range in pairs(ranges) do\n"
"            nranges[#nranges + 1] = {\n"
"                [\"start\"] = 100 * range[\"start\"] / duration,\n"
"                [\"end\"] = 100 * range[\"end\"] / duration,\n"
"            }\n"
"        end\n"
"        return nranges\n"
"    end\n"
"    ne.eventresponder[\"mouse_move\"] = --keyframe seeking when mouse is dragged\n"
"        function (element)\n"
"            -- mouse move events may pile up during seeking and may still get\n"
"            -- sent when the user is done seeking, so we need to throw away\n"
"            -- identical seeks\n"
"            local seekto = get_slider_value(element)\n"
"            if (element.state.lastseek == nil) or\n"
"                (not (element.state.lastseek == seekto)) then\n"
"                    mp.commandv(\"seek\", seekto, \"absolute-percent\",\n"
"                        user_opts.seekbarkeyframes and \"keyframes\" or \"exact\")\n"
"                    element.state.lastseek = seekto\n"
"            end\n"
"\n"
"        end\n"
"    ne.eventresponder[\"mbtn_left_down\"] = --exact seeks on single clicks\n"
"        function (element) mp.commandv(\"seek\", get_slider_value(element),\n"
"            \"absolute-percent\", \"exact\") end\n"
"    ne.eventresponder[\"reset\"] =\n"
"        function (element) element.state.lastseek = nil end\n"
"\n"
"\n"
"    -- tc_left (current pos)\n"
"    ne = new_element(\"tc_left\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        if (state.tc_ms) then\n"
"            return (mp.get_property_osd(\"playback-time/full\"))\n"
"        else\n"
"            return (mp.get_property_osd(\"playback-time\"))\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] = function ()\n"
"        state.tc_ms = not state.tc_ms\n"
"        request_init()\n"
"    end\n"
"\n"
"    -- tc_right (total/remaining time)\n"
"    ne = new_element(\"tc_right\", \"button\")\n"
"\n"
"    ne.visible = (mp.get_property_number(\"duration\", 0) > 0)\n"
"    ne.content = function ()\n"
"        if (state.rightTC_trem) then\n"
"            if state.tc_ms then\n"
"                return (\"-\"..mp.get_property_osd(\"playtime-remaining/full\"))\n"
"            else\n"
"                return (\"-\"..mp.get_property_osd(\"playtime-remaining\"))\n"
"            end\n"
"        else\n"
"            if state.tc_ms then\n"
"                return (mp.get_property_osd(\"duration/full\"))\n"
"            else\n"
"                return (mp.get_property_osd(\"duration\"))\n"
"            end\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () state.rightTC_trem = not state.rightTC_trem end\n"
"\n"
"    -- cache\n"
"    ne = new_element(\"cache\", \"button\")\n"
"\n"
"    ne.content = function ()\n"
"        local cache_state = state.cache_state\n"
"        if not (cache_state and cache_state[\"seekable-ranges\"] and\n"
"            #cache_state[\"seekable-ranges\"] > 0) then\n"
"            -- probably not a network stream\n"
"            return \"\"\n"
"        end\n"
"        local dmx_cache = mp.get_property_number(\"demuxer-cache-duration\")\n"
"        if dmx_cache and (dmx_cache > state.dmx_cache * 1.1 or\n"
"                dmx_cache < state.dmx_cache * 0.9) then\n"
"            state.dmx_cache = dmx_cache\n"
"        else\n"
"            dmx_cache = state.dmx_cache\n"
"        end\n"
"        local min = math.floor(dmx_cache / 60)\n"
"        local sec = dmx_cache % 60\n"
"        return \"Cache: \" .. (min > 0 and\n"
"            string.format(\"%sm%02.0fs\", min, sec) or\n"
"            string.format(\"%3.0fs\", dmx_cache))\n"
"    end\n"
"\n"
"    -- volume\n"
"    ne = new_element(\"volume\", \"button\")\n"
"\n"
"    ne.content = function()\n"
"        local volume = mp.get_property_number(\"volume\", 0)\n"
"        local mute = mp.get_property_native(\"mute\")\n"
"        local volicon = {\"\\238\\132\\139\", \"\\238\\132\\140\",\n"
"                         \"\\238\\132\\141\", \"\\238\\132\\142\"}\n"
"        if volume == 0 or mute then\n"
"            return \"\\238\\132\\138\"\n"
"        else\n"
"            return volicon[math.min(4,math.ceil(volume / (100/3)))]\n"
"        end\n"
"    end\n"
"    ne.eventresponder[\"mbtn_left_up\"] =\n"
"        function () mp.commandv(\"cycle\", \"mute\") end\n"
"\n"
"    ne.eventresponder[\"wheel_up_press\"] =\n"
"        function () mp.commandv(\"osd-auto\", \"add\", \"volume\", 5) end\n"
"    ne.eventresponder[\"wheel_down_press\"] =\n"
"        function () mp.commandv(\"osd-auto\", \"add\", \"volume\", -5) end\n"
"\n"
"\n"
"    -- load layout\n"
"    layouts[user_opts.layout]()\n"
"\n"
"    -- load window controls\n"
"    if window_controls_enabled() then\n"
"        window_controls(user_opts.layout == \"topbar\")\n"
"    end\n"
"\n"
"    --do something with the elements\n"
"    prepare_elements()\n"
"\n"
"    update_margins()\n"
"end\n"
"\n"
"function reset_margins()\n"
"    if state.using_video_margins then\n"
"        for _, opt in ipairs(margins_opts) do\n"
"            mp.set_property_number(opt[2], 0.0)\n"
"        end\n"
"        state.using_video_margins = false\n"
"    end\n"
"end\n"
"\n"
"function update_margins()\n"
"    local margins = osc_param.video_margins\n"
"\n"
"    -- Don't use margins if it's visible only temporarily.\n"
"    if (not state.osc_visible) or (get_hidetimeout() >= 0) then\n"
"        margins = {l = 0, r = 0, t = 0, b = 0}\n"
"    end\n"
"\n"
"    if user_opts.boxvideo then\n"
"        -- check whether any margin option has a non-default value\n"
"        local margins_used = false\n"
"\n"
"        if not state.using_video_margins then\n"
"            for _, opt in ipairs(margins_opts) do\n"
"                if mp.get_property_number(opt[2], 0.0) ~= 0.0 then\n"
"                    margins_used = true\n"
"                end\n"
"            end\n"
"        end\n"
"\n"
"        if not margins_used then\n"
"            for _, opt in ipairs(margins_opts) do\n"
"                local v = margins[opt[1]]\n"
"                if (v ~= 0) or state.using_video_margins then\n"
"                    mp.set_property_number(opt[2], v)\n"
"                    state.using_video_margins = true\n"
"                end\n"
"            end\n"
"        end\n"
"    else\n"
"        reset_margins()\n"
"    end\n"
"\n"
"    utils.shared_script_property_set(\"osc-margins\",\n"
"        string.format(\"%f,%f,%f,%f\", margins.l, margins.r, margins.t, margins.b))\n"
"end\n"
"\n"
"function shutdown()\n"
"    reset_margins()\n"
"    utils.shared_script_property_set(\"osc-margins\", nil)\n"
"end\n"
"\n"
"--\n"
"-- Other important stuff\n"
"--\n"
"\n"
"\n"
"function show_osc()\n"
"    -- show when disabled can happen (e.g. mouse_move) due to async/delayed unbinding\n"
"    if not state.enabled then return end\n"
"\n"
"    msg.trace(\"show_osc\")\n"
"    --remember last time of invocation (mouse move)\n"
"    state.showtime = mp.get_time()\n"
"\n"
"    osc_visible(true)\n"
"\n"
"    if (user_opts.fadeduration > 0) then\n"
"        state.anitype = nil\n"
"    end\n"
"end\n"
"\n"
"function hide_osc()\n"
"    msg.trace(\"hide_osc\")\n"
"    if not state.enabled then\n"
"        -- typically hide happens at render() from tick(), but now tick() is\n"
"        -- no-op and won't render again to remove the osc, so do that manually.\n"
"        state.osc_visible = false\n"
"        render_wipe()\n"
"    elseif (user_opts.fadeduration > 0) then\n"
"        if not(state.osc_visible == false) then\n"
"            state.anitype = \"out\"\n"
"            request_tick()\n"
"        end\n"
"    else\n"
"        osc_visible(false)\n"
"    end\n"
"end\n"
"\n"
"function osc_visible(visible)\n"
"    if state.osc_visible ~= visible then\n"
"        state.osc_visible = visible\n"
"        update_margins()\n"
"    end\n"
"    request_tick()\n"
"end\n"
"\n"
"function pause_state(name, enabled)\n"
"    state.paused = enabled\n"
"    request_tick()\n"
"end\n"
"\n"
"function cache_state(name, st)\n"
"    state.cache_state = st\n"
"    request_tick()\n"
"end\n"
"\n"
"-- Request that tick() is called (which typically re-renders the OSC).\n"
"-- The tick is then either executed immediately, or rate-limited if it was\n"
"-- called a small time ago.\n"
"function request_tick()\n"
"    if state.tick_timer == nil then\n"
"        state.tick_timer = mp.add_timeout(0, tick)\n"
"    end\n"
"\n"
"    if not state.tick_timer:is_enabled() then\n"
"        local now = mp.get_time()\n"
"        local timeout = tick_delay - (now - state.tick_last_time)\n"
"        if timeout < 0 then\n"
"            timeout = 0\n"
"        end\n"
"        state.tick_timer.timeout = timeout\n"
"        state.tick_timer:resume()\n"
"    end\n"
"end\n"
"\n"
"function mouse_leave()\n"
"    if get_hidetimeout() >= 0 then\n"
"        hide_osc()\n"
"    end\n"
"    -- reset mouse position\n"
"    state.last_mouseX, state.last_mouseY = nil, nil\n"
"end\n"
"\n"
"function request_init()\n"
"    state.initREQ = true\n"
"end\n"
"\n"
"function render_wipe()\n"
"    msg.trace(\"render_wipe()\")\n"
"    state.osd:remove()\n"
"end\n"
"\n"
"function render()\n"
"    msg.trace(\"rendering\")\n"
"    local current_screen_sizeX, current_screen_sizeY, aspect = mp.get_osd_size()\n"
"    local mouseX, mouseY = get_virt_mouse_pos()\n"
"    local now = mp.get_time()\n"
"\n"
"    -- check if display changed, if so request reinit\n"
"    if not (state.mp_screen_sizeX == current_screen_sizeX\n"
"        and state.mp_screen_sizeY == current_screen_sizeY) then\n"
"\n"
"        request_init()\n"
"\n"
"        state.mp_screen_sizeX = current_screen_sizeX\n"
"        state.mp_screen_sizeY = current_screen_sizeY\n"
"    end\n"
"\n"
"    -- init management\n"
"    if state.initREQ then\n"
"        osc_init()\n"
"        state.initREQ = false\n"
"\n"
"        -- store initial mouse position\n"
"        if (state.last_mouseX == nil or state.last_mouseY == nil)\n"
"            and not (mouseX == nil or mouseY == nil) then\n"
"\n"
"            state.last_mouseX, state.last_mouseY = mouseX, mouseY\n"
"        end\n"
"    end\n"
"\n"
"\n"
"    -- fade animation\n"
"    if not(state.anitype == nil) then\n"
"\n"
"        if (state.anistart == nil) then\n"
"            state.anistart = now\n"
"        end\n"
"\n"
"        if (now < state.anistart + (user_opts.fadeduration/1000)) then\n"
"\n"
"            if (state.anitype == \"in\") then --fade in\n"
"                osc_visible(true)\n"
"                state.animation = scale_value(state.anistart,\n"
"                    (state.anistart + (user_opts.fadeduration/1000)),\n"
"                    255, 0, now)\n"
"            elseif (state.anitype == \"out\") then --fade out\n"
"                state.animation = scale_value(state.anistart,\n"
"                    (state.anistart + (user_opts.fadeduration/1000)),\n"
"                    0, 255, now)\n"
"            end\n"
"\n"
"        else\n"
"            if (state.anitype == \"out\") then\n"
"                osc_visible(false)\n"
"            end\n"
"            state.anistart = nil\n"
"            state.animation = nil\n"
"            state.anitype =  nil\n"
"        end\n"
"    else\n"
"        state.anistart = nil\n"
"        state.animation = nil\n"
"        state.anitype =  nil\n"
"    end\n"
"\n"
"    --mouse show/hide area\n"
"    for k,cords in pairs(osc_param.areas[\"showhide\"]) do\n"
"        set_virt_mouse_area(cords.x1, cords.y1, cords.x2, cords.y2, \"showhide\")\n"
"    end\n"
"    if osc_param.areas[\"showhide_wc\"] then\n"
"        for k,cords in pairs(osc_param.areas[\"showhide_wc\"]) do\n"
"            set_virt_mouse_area(cords.x1, cords.y1, cords.x2, cords.y2, \"showhide_wc\")\n"
"        end\n"
"    else\n"
"        set_virt_mouse_area(0, 0, 0, 0, \"showhide_wc\")\n"
"    end\n"
"    do_enable_keybindings()\n"
"\n"
"    --mouse input area\n"
"    local mouse_over_osc = false\n"
"\n"
"    for _,cords in ipairs(osc_param.areas[\"input\"]) do\n"
"        if state.osc_visible then -- activate only when OSC is actually visible\n"
"            set_virt_mouse_area(cords.x1, cords.y1, cords.x2, cords.y2, \"input\")\n"
"        end\n"
"        if state.osc_visible ~= state.input_enabled then\n"
"            if state.osc_visible then\n"
"                mp.enable_key_bindings(\"input\")\n"
"            else\n"
"                mp.disable_key_bindings(\"input\")\n"
"            end\n"
"            state.input_enabled = state.osc_visible\n"
"        end\n"
"\n"
"        if (mouse_hit_coords(cords.x1, cords.y1, cords.x2, cords.y2)) then\n"
"            mouse_over_osc = true\n"
"        end\n"
"    end\n"
"\n"
"    if osc_param.areas[\"window-controls\"] then\n"
"        for _,cords in ipairs(osc_param.areas[\"window-controls\"]) do\n"
"            if state.osc_visible then -- activate only when OSC is actually visible\n"
"                set_virt_mouse_area(cords.x1, cords.y1, cords.x2, cords.y2, \"window-controls\")\n"
"                mp.enable_key_bindings(\"window-controls\")\n"
"            else\n"
"                mp.disable_key_bindings(\"window-controls\")\n"
"            end\n"
"\n"
"            if (mouse_hit_coords(cords.x1, cords.y1, cords.x2, cords.y2)) then\n"
"                mouse_over_osc = true\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    -- autohide\n"
"    if not (state.showtime == nil) and (get_hidetimeout() >= 0) then\n"
"        local timeout = state.showtime + (get_hidetimeout()/1000) - now\n"
"        if timeout <= 0 then\n"
"            if (state.active_element == nil) and not (mouse_over_osc) then\n"
"                hide_osc()\n"
"            end\n"
"        else\n"
"            -- the timer is only used to recheck the state and to possibly run\n"
"            -- the code above again\n"
"            if not state.hide_timer then\n"
"                state.hide_timer = mp.add_timeout(0, tick)\n"
"            end\n"
"            state.hide_timer.timeout = timeout\n"
"            -- re-arm\n"
"            state.hide_timer:kill()\n"
"            state.hide_timer:resume()\n"
"        end\n"
"    end\n"
"\n"
"\n"
"    -- actual rendering\n"
"    local ass = assdraw.ass_new()\n"
"\n"
"    -- Messages\n"
"    render_message(ass)\n"
"\n"
"    -- actual OSC\n"
"    if state.osc_visible then\n"
"        render_elements(ass)\n"
"    end\n"
"\n"
"    -- submit\n"
"    set_osd(osc_param.playresy * osc_param.display_aspect,\n"
"            osc_param.playresy, ass.text)\n"
"end\n"
"\n"
"--\n"
"-- Eventhandling\n"
"--\n"
"\n"
"local function element_has_action(element, action)\n"
"    return element and element.eventresponder and\n"
"        element.eventresponder[action]\n"
"end\n"
"\n"
"function process_event(source, what)\n"
"    local action = string.format(\"%s%s\", source,\n"
"        what and (\"_\" .. what) or \"\")\n"
"\n"
"    if what == \"down\" or what == \"press\" then\n"
"\n"
"        for n = 1, #elements do\n"
"\n"
"            if mouse_hit(elements[n]) and\n"
"                elements[n].eventresponder and\n"
"                (elements[n].eventresponder[source .. \"_up\"] or\n"
"                    elements[n].eventresponder[action]) then\n"
"\n"
"                if what == \"down\" then\n"
"                    state.active_element = n\n"
"                    state.active_event_source = source\n"
"                end\n"
"                -- fire the down or press event if the element has one\n"
"                if element_has_action(elements[n], action) then\n"
"                    elements[n].eventresponder[action](elements[n])\n"
"                end\n"
"\n"
"            end\n"
"        end\n"
"\n"
"    elseif what == \"up\" then\n"
"\n"
"        if elements[state.active_element] then\n"
"            local n = state.active_element\n"
"\n"
"            if n == 0 then\n"
"                --click on background (does not work)\n"
"            elseif element_has_action(elements[n], action) and\n"
"                mouse_hit(elements[n]) then\n"
"\n"
"                elements[n].eventresponder[action](elements[n])\n"
"            end\n"
"\n"
"            --reset active element\n"
"            if element_has_action(elements[n], \"reset\") then\n"
"                elements[n].eventresponder[\"reset\"](elements[n])\n"
"            end\n"
"\n"
"        end\n"
"        state.active_element = nil\n"
"        state.mouse_down_counter = 0\n"
"\n"
"    elseif source == \"mouse_move\" then\n"
"\n"
"        local mouseX, mouseY = get_virt_mouse_pos()\n"
"        if (user_opts.minmousemove == 0) or\n"
"            (not ((state.last_mouseX == nil) or (state.last_mouseY == nil)) and\n"
"                ((math.abs(mouseX - state.last_mouseX) >= user_opts.minmousemove)\n"
"                    or (math.abs(mouseY - state.last_mouseY) >= user_opts.minmousemove)\n"
"                )\n"
"            ) then\n"
"            show_osc()\n"
"        end\n"
"        state.last_mouseX, state.last_mouseY = mouseX, mouseY\n"
"\n"
"        local n = state.active_element\n"
"        if element_has_action(elements[n], action) then\n"
"            elements[n].eventresponder[action](elements[n])\n"
"        end\n"
"        request_tick()\n"
"    end\n"
"end\n"
"\n"
"\n"
"local logo_lines = {\n"
"    -- White border\n"
"    \"{\\\\c&HE5E5E5&\\\\p6}m 895 10 b 401 10 0 410 0 905 0 1399 401 1800 895 1800 1390 1800 1790 1399 1790 905 1790 410 1390 10 895 10 {\\\\p0}\",\n"
"    -- Purple fill\n"
"    \"{\\\\c&H682167&\\\\p6}m 925 42 b 463 42 87 418 87 880 87 1343 463 1718 925 1718 1388 1718 1763 1343 1763 880 1763 418 1388 42 925 42{\\\\p0}\",\n"
"    -- Darker fill\n"
"    \"{\\\\c&H430142&\\\\p6}m 1605 828 b 1605 1175 1324 1456 977 1456 631 1456 349 1175 349 828 349 482 631 200 977 200 1324 200 1605 482 1605 828{\\\\p0}\",\n"
"    -- White fill\n"
"    \"{\\\\c&HDDDBDD&\\\\p6}m 1296 910 b 1296 1131 1117 1310 897 1310 676 1310 497 1131 497 910 497 689 676 511 897 511 1117 511 1296 689 1296 910{\\\\p0}\",\n"
"    -- Triangle\n"
"    \"{\\\\c&H691F69&\\\\p6}m 762 1113 l 762 708 b 881 776 1000 843 1119 911 1000 978 881 1046 762 1113{\\\\p0}\",\n"
"}\n"
"\n"
"local santa_hat_lines = {\n"
"    -- Pompoms\n"
"    \"{\\\\c&HC0C0C0&\\\\p6}m 500 -323 b 491 -322 481 -318 475 -311 465 -312 456 -319 446 -318 434 -314 427 -304 417 -297 410 -290 404 -282 395 -278 390 -274 387 -267 381 -265 377 -261 379 -254 384 -253 397 -244 409 -232 425 -228 437 -228 446 -218 457 -217 462 -216 466 -213 468 -209 471 -205 477 -203 482 -206 491 -211 499 -217 508 -222 532 -235 556 -249 576 -267 584 -272 584 -284 578 -290 569 -305 550 -312 533 -309 523 -310 515 -316 507 -321 505 -323 503 -323 500 -323{\\\\p0}\",\n"
"    \"{\\\\c&HE0E0E0&\\\\p6}m 315 -260 b 286 -258 259 -240 246 -215 235 -210 222 -215 211 -211 204 -188 177 -176 172 -151 170 -139 163 -128 154 -121 143 -103 141 -81 143 -60 139 -46 125 -34 129 -17 132 -1 134 16 142 30 145 56 161 80 181 96 196 114 210 133 231 144 266 153 303 138 328 115 373 79 401 28 423 -24 446 -73 465 -123 483 -174 487 -199 467 -225 442 -227 421 -232 402 -242 384 -254 364 -259 342 -250 322 -260 320 -260 317 -261 315 -260{\\\\p0}\",\n"
"    -- Main cap\n"
"    \"{\\\\c&H0000F0&\\\\p6}m 1151 -523 b 1016 -516 891 -458 769 -406 693 -369 624 -319 561 -262 526 -252 465 -235 479 -187 502 -147 551 -135 588 -111 1115 165 1379 232 1909 761 1926 800 1952 834 1987 858 2020 883 2053 912 2065 952 2088 1000 2146 962 2139 919 2162 836 2156 747 2143 662 2131 615 2116 567 2122 517 2120 410 2090 306 2089 199 2092 147 2071 99 2034 64 1987 5 1928 -41 1869 -86 1777 -157 1712 -256 1629 -337 1578 -389 1521 -436 1461 -476 1407 -509 1343 -507 1284 -515 1240 -519 1195 -521 1151 -523{\\\\p0}\",\n"
"    -- Cap shadow\n"
"    \"{\\\\c&H0000AA&\\\\p6}m 1657 248 b 1658 254 1659 261 1660 267 1669 276 1680 284 1689 293 1695 302 1700 311 1707 320 1716 325 1726 330 1735 335 1744 347 1752 360 1761 371 1753 352 1754 331 1753 311 1751 237 1751 163 1751 90 1752 64 1752 37 1767 14 1778 -3 1785 -24 1786 -45 1786 -60 1786 -77 1774 -87 1760 -96 1750 -78 1751 -65 1748 -37 1750 -8 1750 20 1734 78 1715 134 1699 192 1694 211 1689 231 1676 246 1671 251 1661 255 1657 248 m 1909 541 b 1914 542 1922 549 1917 539 1919 520 1921 502 1919 483 1918 458 1917 433 1915 407 1930 373 1942 338 1947 301 1952 270 1954 238 1951 207 1946 214 1947 229 1945 239 1939 278 1936 318 1924 356 1923 362 1913 382 1912 364 1906 301 1904 237 1891 175 1887 150 1892 126 1892 101 1892 68 1893 35 1888 2 1884 -9 1871 -20 1859 -14 1851 -6 1854 9 1854 20 1855 58 1864 95 1873 132 1883 179 1894 225 1899 273 1908 362 1910 451 1909 541{\\\\p0}\",\n"
"    -- Brim and tip pompom\n"
"    \"{\\\\c&HF8F8F8&\\\\p6}m 626 -191 b 565 -155 486 -196 428 -151 387 -115 327 -101 304 -47 273 2 267 59 249 113 219 157 217 213 215 265 217 309 260 302 285 283 373 264 465 264 555 257 608 252 655 292 709 287 759 294 816 276 863 298 903 340 972 324 1012 367 1061 394 1125 382 1167 424 1213 462 1268 482 1322 506 1385 546 1427 610 1479 662 1510 690 1534 725 1566 752 1611 796 1664 830 1703 880 1740 918 1747 986 1805 1005 1863 991 1897 932 1916 880 1914 823 1945 777 1961 725 1979 673 1957 622 1938 575 1912 534 1862 515 1836 473 1790 417 1755 351 1697 305 1658 266 1633 216 1593 176 1574 138 1539 116 1497 110 1448 101 1402 77 1371 37 1346 -16 1295 15 1254 6 1211 -27 1170 -62 1121 -86 1072 -104 1027 -128 976 -133 914 -130 851 -137 794 -162 740 -181 679 -168 626 -191 m 2051 917 b 1971 932 1929 1017 1919 1091 1912 1149 1923 1214 1970 1254 2000 1279 2027 1314 2066 1325 2139 1338 2212 1295 2254 1238 2281 1203 2287 1158 2282 1116 2292 1061 2273 1006 2229 970 2206 941 2167 938 2138 918{\\\\p0}\",\n"
"}\n"
"\n"
"-- called by mpv on every frame\n"
"function tick()\n"
"    if (not state.enabled) then return end\n"
"\n"
"    if (state.idle) then\n"
"\n"
"        -- render idle message\n"
"        msg.trace(\"idle message\")\n"
"        local icon_x, icon_y = 320 - 26, 140\n"
"        local line_prefix = (\"{\\\\rDefault\\\\an7\\\\1a&H00&\\\\bord0\\\\shad0\\\\pos(%f,%f)}\"):format(icon_x, icon_y)\n"
"\n"
"        local ass = assdraw.ass_new()\n"
"        -- mpv logo\n"
"        for i, line in ipairs(logo_lines) do\n"
"            ass:new_event()\n"
"            ass:append(line_prefix .. line)\n"
"        end\n"
"\n"
"        -- Santa hat\n"
"        if is_december and not user_opts.greenandgrumpy then\n"
"            for i, line in ipairs(santa_hat_lines) do\n"
"                ass:new_event()\n"
"                ass:append(line_prefix .. line)\n"
"            end\n"
"        end\n"
"\n"
"        ass:new_event()\n"
"        ass:pos(320, icon_y+65)\n"
"        ass:an(8)\n"
"        ass:append(\"Drop files or URLs to play here.\")\n"
"        set_osd(640, 360, ass.text)\n"
"\n"
"        if state.showhide_enabled then\n"
"            mp.disable_key_bindings(\"showhide\")\n"
"            mp.disable_key_bindings(\"showhide_wc\")\n"
"            state.showhide_enabled = false\n"
"        end\n"
"\n"
"\n"
"    elseif (state.fullscreen and user_opts.showfullscreen)\n"
"        or (not state.fullscreen and user_opts.showwindowed) then\n"
"\n"
"        -- render the OSC\n"
"        render()\n"
"    else\n"
"        -- Flush OSD\n"
"        set_osd(osc_param.playresy, osc_param.playresy, \"\")\n"
"    end\n"
"\n"
"    state.tick_last_time = mp.get_time()\n"
"\n"
"    if state.anitype ~= nil then\n"
"        request_tick()\n"
"    end\n"
"end\n"
"\n"
"function do_enable_keybindings()\n"
"    if state.enabled then\n"
"        if not state.showhide_enabled then\n"
"            mp.enable_key_bindings(\"showhide\", \"allow-vo-dragging+allow-hide-cursor\")\n"
"            mp.enable_key_bindings(\"showhide_wc\", \"allow-vo-dragging+allow-hide-cursor\")\n"
"        end\n"
"        state.showhide_enabled = true\n"
"    end\n"
"end\n"
"\n"
"function enable_osc(enable)\n"
"    state.enabled = enable\n"
"    if enable then\n"
"        do_enable_keybindings()\n"
"    else\n"
"        hide_osc() -- acts immediately when state.enabled == false\n"
"        if state.showhide_enabled then\n"
"            mp.disable_key_bindings(\"showhide\")\n"
"            mp.disable_key_bindings(\"showhide_wc\")\n"
"        end\n"
"        state.showhide_enabled = false\n"
"    end\n"
"end\n"
"\n"
"validate_user_opts()\n"
"\n"
"mp.register_event(\"shutdown\", shutdown)\n"
"mp.register_event(\"start-file\", request_init)\n"
"mp.register_event(\"tracks-changed\", request_init)\n"
"mp.observe_property(\"playlist\", nil, request_init)\n"
"\n"
"mp.register_script_message(\"osc-message\", show_message)\n"
"mp.register_script_message(\"osc-chapterlist\", function(dur)\n"
"    show_message(get_chapterlist(), dur)\n"
"end)\n"
"mp.register_script_message(\"osc-playlist\", function(dur)\n"
"    show_message(get_playlist(), dur)\n"
"end)\n"
"mp.register_script_message(\"osc-tracklist\", function(dur)\n"
"    local msg = {}\n"
"    for k,v in pairs(nicetypes) do\n"
"        table.insert(msg, get_tracklist(k))\n"
"    end\n"
"    show_message(table.concat(msg, '\\n\\n'), dur)\n"
"end)\n"
"\n"
"mp.observe_property(\"fullscreen\", \"bool\",\n"
"    function(name, val)\n"
"        state.fullscreen = val\n"
"        request_init()\n"
"    end\n"
")\n"
"mp.observe_property(\"border\", \"bool\",\n"
"    function(name, val)\n"
"        state.border = val\n"
"        request_init()\n"
"    end\n"
")\n"
"mp.observe_property(\"window-maximized\", \"bool\",\n"
"    function(name, val)\n"
"        state.maximized = val\n"
"        request_init()\n"
"    end\n"
")\n"
"mp.observe_property(\"idle-active\", \"bool\",\n"
"    function(name, val)\n"
"        state.idle = val\n"
"        request_tick()\n"
"    end\n"
")\n"
"mp.observe_property(\"pause\", \"bool\", pause_state)\n"
"mp.observe_property(\"demuxer-cache-state\", \"native\", cache_state)\n"
"mp.observe_property(\"vo-configured\", \"bool\", function(name, val)\n"
"    request_tick()\n"
"end)\n"
"mp.observe_property(\"playback-time\", \"number\", function(name, val)\n"
"    request_tick()\n"
"end)\n"
"\n"
"-- mouse show/hide bindings\n"
"mp.set_key_bindings({\n"
"    {\"mouse_move\",              function(e) process_event(\"mouse_move\", nil) end},\n"
"    {\"mouse_leave\",             mouse_leave},\n"
"}, \"showhide\", \"force\")\n"
"mp.set_key_bindings({\n"
"    {\"mouse_move\",              function(e) process_event(\"mouse_move\", nil) end},\n"
"    {\"mouse_leave\",             mouse_leave},\n"
"}, \"showhide_wc\", \"force\")\n"
"do_enable_keybindings()\n"
"\n"
"--mouse input bindings\n"
"mp.set_key_bindings({\n"
"    {\"mbtn_left\",           function(e) process_event(\"mbtn_left\", \"up\") end,\n"
"                            function(e) process_event(\"mbtn_left\", \"down\")  end},\n"
"    {\"shift+mbtn_left\",     function(e) process_event(\"shift+mbtn_left\", \"up\") end,\n"
"                            function(e) process_event(\"shift+mbtn_left\", \"down\")  end},\n"
"    {\"mbtn_right\",          function(e) process_event(\"mbtn_right\", \"up\") end,\n"
"                            function(e) process_event(\"mbtn_right\", \"down\")  end},\n"
"    -- alias to shift_mbtn_left for single-handed mouse use\n"
"    {\"mbtn_mid\",            function(e) process_event(\"shift+mbtn_left\", \"up\") end,\n"
"                            function(e) process_event(\"shift+mbtn_left\", \"down\")  end},\n"
"    {\"wheel_up\",            function(e) process_event(\"wheel_up\", \"press\") end},\n"
"    {\"wheel_down\",          function(e) process_event(\"wheel_down\", \"press\") end},\n"
"    {\"mbtn_left_dbl\",       \"ignore\"},\n"
"    {\"shift+mbtn_left_dbl\", \"ignore\"},\n"
"    {\"mbtn_right_dbl\",      \"ignore\"},\n"
"}, \"input\", \"force\")\n"
"mp.enable_key_bindings(\"input\")\n"
"\n"
"mp.set_key_bindings({\n"
"    {\"mbtn_left\",           function(e) process_event(\"mbtn_left\", \"up\") end,\n"
"                            function(e) process_event(\"mbtn_left\", \"down\")  end},\n"
"}, \"window-controls\", \"force\")\n"
"mp.enable_key_bindings(\"window-controls\")\n"
"\n"
"function get_hidetimeout()\n"
"    if user_opts.visibility == \"always\" then\n"
"        return -1 -- disable autohide\n"
"    end\n"
"    return user_opts.hidetimeout\n"
"end\n"
"\n"
"function always_on(val)\n"
"    if state.enabled then\n"
"        if val then\n"
"            show_osc()\n"
"        else\n"
"            hide_osc()\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"-- mode can be auto/always/never/cycle\n"
"-- the modes only affect internal variables and not stored on its own.\n"
"function visibility_mode(mode, no_osd)\n"
"    if mode == \"cycle\" then\n"
"        if not state.enabled then\n"
"            mode = \"auto\"\n"
"        elseif user_opts.visibility ~= \"always\" then\n"
"            mode = \"always\"\n"
"        else\n"
"            mode = \"never\"\n"
"        end\n"
"    end\n"
"\n"
"    if mode == \"auto\" then\n"
"        always_on(false)\n"
"        enable_osc(true)\n"
"    elseif mode == \"always\" then\n"
"        enable_osc(true)\n"
"        always_on(true)\n"
"    elseif mode == \"never\" then\n"
"        enable_osc(false)\n"
"    else\n"
"        msg.warn(\"Ignoring unknown visibility mode '\" .. mode .. \"'\")\n"
"        return\n"
"    end\n"
"\n"
"    user_opts.visibility = mode\n"
"\n"
"    if not no_osd and tonumber(mp.get_property(\"osd-level\")) >= 1 then\n"
"        mp.osd_message(\"OSC visibility: \" .. mode)\n"
"    end\n"
"\n"
"    update_margins()\n"
"    request_tick()\n"
"end\n"
"\n"
"visibility_mode(user_opts.visibility, true)\n"
"mp.register_script_message(\"osc-visibility\", visibility_mode)\n"
"mp.add_key_binding(nil, \"visibility\", function() visibility_mode(\"cycle\") end)\n"
"\n"
"set_virt_mouse_area(0, 0, 0, 0, \"input\")\n"
"set_virt_mouse_area(0, 0, 0, 0, \"window-controls\")\n"
